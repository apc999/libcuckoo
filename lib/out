commit c4b6a4d83df5c3192e28c54cbadde40aef381c67
Author: Dave Andersen <dga@cs.cmu.edu>
Date:   Tue Jun 25 15:48:01 2013 -0400

    typo fix in comment

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index 488aa39..5fb2f9f 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -120,7 +120,7 @@ Bucket;
     } while(0)
 
 
-// dga does not thing we need this mfence in end_incr, because
+// dga does not think we need this mfence in end_incr, because
 // the current code will call pthread_mutex_unlock before returning
 // to the caller;  pthread_mutex_unlock is a memory barrier:
 // http://www.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_11

commit 24591f69d78eae0be6e4320971bce8f480adc6c9
Author: Dave Andersen <dga@cs.cmu.edu>
Date:   Fri Jun 21 11:52:59 2013 -0400

    Fix alt_hash = 0 bug (dong zhou fix);  use thread local storage to reduce malloc invocations (dga+xiaozhou fix)

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index 8b0062e..488aa39 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -164,7 +164,7 @@ static inline size_t _alt_index(cuckoo_hashtable_t* h,
                                 const size_t index) {
     // 0x5bd1e995 is the hash constant from MurmurHash2
     //uint32_t tag = hv & 0xFF;
-    uint32_t tag = hv >> 24;
+    uint32_t tag = (hv >> 24)+1; // ensure tag is nonzero for the multiply
     return (index ^ (tag * 0x5bd1e995)) & hashmask(h->hashpower);
     //return (hv ^ (tag * 0x5bd1e995)) & hashmask(h->hashpower);
     //return ((hv >> 32) & hashmask(h->hashpower));
@@ -323,10 +323,13 @@ static bool _run_cuckoo(cuckoo_hashtable_t* h,
                         size_t i2,
                         size_t* i) {
 
-    CuckooRecord* cuckoo_path = malloc(MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
-    if (!cuckoo_path) {
-        fprintf(stderr, "Failed to init cuckoo path.\n");
-        return -1;
+    static __thread CuckooRecord* cuckoo_path = NULL;
+    if (!cuckoo_path) { 
+	cuckoo_path = malloc(MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
+        if (!cuckoo_path) {
+            fprintf(stderr, "Failed to init cuckoo path.\n");
+            return -1;
+        }
     }
     memset(cuckoo_path, 0, MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
 
@@ -351,11 +354,9 @@ static bool _run_cuckoo(cuckoo_hashtable_t* h,
         int curr_depth = _cuckoopath_move(h, cuckoo_path, depth, idx);
         if (curr_depth == 0) {
             *i = cuckoo_path[0].buckets[idx];
-            free(cuckoo_path);
             return true;
         }
     }
-    free(cuckoo_path);
     return false;
 }
 

commit f9dfa111edec33c62fc1edba6d991ada3d054930
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Mon Apr 29 22:36:16 2013 -0400

    code cleanup

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index 089b386..8b0062e 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -43,15 +43,10 @@ typedef struct {
 }  __attribute__((__packed__))
 Bucket;
 
-// the old code
-/* #define read_keyver(h, idx)                                      \ */
-/*     __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 0) */
 
-/* #define incr_keyver(h, idx)                                      \ */
-/*     __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 1) */
-
-#define likely(x)     __builtin_expect(!!(x), 1)
-#define unlikely(x)   __builtin_expect(!!(x), 0)
+#define reorder_barrier() __asm__ __volatile__("" ::: "memory")
+#define likely(x)     __builtin_expect((x), 1)
+#define unlikely(x)   __builtin_expect((x), 0)
 
 /**
  *  @brief read the counter, ensured by x86 memory ordering model
@@ -60,12 +55,12 @@ Bucket;
 #define start_read_counter(h, idx, version)                             \
     do {                                                                \
         version = *(volatile uint32_t *)(&((uint32_t*) h->counters)[idx & counter_mask]); \
-        __asm__ __volatile__("" ::: "memory");                          \
+        reorder_barrier();                                              \
     } while(0)
 
 #define end_read_counter(h, idx, version)                               \
     do {                                                                \
-        __asm__ __volatile__("" ::: "memory");                          \
+        reorder_barrier();                                              \
         version = *(volatile uint32_t *)(&((uint32_t*) h->counters)[idx & counter_mask]); \
     } while (0)
 
@@ -74,12 +69,12 @@ Bucket;
     do {                                                                \
         v1 = *(volatile uint32_t *)(&((uint32_t*) h->counters)[i1 & counter_mask]); \
         v2 = *(volatile uint32_t *)(&((uint32_t*) h->counters)[i2 & counter_mask]); \
-        __asm__ __volatile__("" ::: "memory");                          \
+        reorder_barrier();                                              \
     } while(0)
 
 #define end_read_counter2(h, i1, i2, v1, v2)                            \
     do {                                                                \
-        __asm__ __volatile__("" ::: "memory");                          \
+        reorder_barrier();                                              \
         v1 = *(volatile uint32_t *)(&((uint32_t*) h->counters)[i1 & counter_mask]); \
         v2 = *(volatile uint32_t *)(&((uint32_t*) h->counters)[i2 & counter_mask]); \
     } while (0)
@@ -92,12 +87,12 @@ Bucket;
 #define start_incr_counter(h, idx)                                  \
     do {                                                            \
         ((volatile uint32_t *)h->counters)[idx & counter_mask]++;   \
-        __asm__ __volatile__("" ::: "memory");                      \
+        reorder_barrier();                                          \
     } while(0)
 
 #define end_incr_counter(h, idx)                                    \
     do {                                                            \
-        __asm__ __volatile__("" ::: "memory");                      \
+        reorder_barrier();                                          \
         ((volatile uint32_t*) h->counters)[idx & counter_mask]++;   \
     } while(0)
 
@@ -110,13 +105,13 @@ Bucket;
         } else {                                                        \
             ((volatile uint32_t *)h->counters)[i1 & counter_mask]++;    \
         }                                                               \
-        __asm__ __volatile__("" ::: "memory");                          \
+        reorder_barrier();                                              \
     } while(0)
 
 #define end_incr_counter2(h, i1, i2)                                    \
     do {                                                                \
-        __asm__ __volatile__("" ::: "memory");                          \
-        if (likely((i1 & counter_mask) != (i2 & counter_mask))) {     \
+        reorder_barrier();                                              \
+        if (likely((i1 & counter_mask) != (i2 & counter_mask))) {       \
             ((volatile uint32_t *)h->counters)[i1 & counter_mask]++;    \
             ((volatile uint32_t *)h->counters)[i2 & counter_mask]++;    \
         } else {                                                        \
@@ -175,25 +170,11 @@ static inline size_t _alt_index(cuckoo_hashtable_t* h,
     //return ((hv >> 32) & hashmask(h->hashpower));
 }
 
-/**
- * @brief Compute the index of the corresponding counter in keyver_array
- *
- * @param hv 32-bit hash value of the key
- *
- * @return The index of the counter
- */
-/* static inline size_t _lock_index(const uint32_t hv) { */
-/*     return hv & keyver_mask; */
-/* } */
-
 
 #define TABLE_KEY(h, i, j) ((Bucket*) h->buckets)[i].keys[j]
 #define TABLE_VAL(h, i, j) ((Bucket*) h->buckets)[i].vals[j]
 
-//static uint8_t valid_op[] = {0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
-//static uint8_t invalid_op[] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};
-
-#define SLOT_CLEAN(h, i, j)                \
+#define SLOT_CLEAN(h, i, j)                     \
     do {                                        \
         TABLE_KEY(h, i, j) = 0;                 \
     } while(0)
@@ -202,14 +183,9 @@ static inline size_t _alt_index(cuckoo_hashtable_t* h,
 
 
 
-//#define IS_SLOT_EMPTY(h, i, j) (TABLE_KEY(h, i, j)==0)
 static inline bool is_slot_empty(cuckoo_hashtable_t* h,
                                  size_t i,
                                  size_t j) {
-    /* if (TABLE_KEY(h, i, j)==0) { */
-    /*     return true; */
-    /* } */
-
     if (IS_SLOT_AVAILABLE(h, i, j)) {
         return true;
     }
@@ -220,8 +196,8 @@ static inline bool is_slot_empty(cuckoo_hashtable_t* h,
         uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
         size_t i1 = _index_hash(h, hv);
         size_t i2 = _alt_index(h, hv, i1);
-        if ((i != i1) && (i != i2)) {
 
+        if ((i != i1) && (i != i2)) {
             SLOT_CLEAN(h, i, j);
             return true;
         }
@@ -347,17 +323,14 @@ static bool _run_cuckoo(cuckoo_hashtable_t* h,
                         size_t i2,
                         size_t* i) {
 
-    CuckooRecord* cuckoo_path;
-
-    cuckoo_path = malloc(MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
-    if (! cuckoo_path) {
+    CuckooRecord* cuckoo_path = malloc(MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
+    if (!cuckoo_path) {
         fprintf(stderr, "Failed to init cuckoo path.\n");
         return -1;
     }
     memset(cuckoo_path, 0, MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
 
-    size_t idx;
-    for (idx = 0; idx < NUM_CUCKOO_PATH; idx++) {
+    for (size_t idx = 0; idx < NUM_CUCKOO_PATH; idx++) {
         if (idx < NUM_CUCKOO_PATH / 2) {
             cuckoo_path[0].buckets[idx] = i1;
         } else {
@@ -365,10 +338,12 @@ static bool _run_cuckoo(cuckoo_hashtable_t* h,
         }
     }
 
-    size_t num_kicks = 0;
+
     while (1) {
-        int depth;
-        depth = _cuckoopath_search(h, cuckoo_path, &idx, &num_kicks);
+        size_t num_kicks = 0;
+        size_t idx = 0;
+
+        int depth = _cuckoopath_search(h, cuckoo_path, &idx, &num_kicks);
         if (depth < 0) {
             break;
         }
@@ -488,7 +463,7 @@ static cuckoo_status _cuckoo_find(cuckoo_hashtable_t* h,
 TryRead:
     start_read_counter2(h, i1, i2, vs1, vs2);
 
-    if ((vs1 & 1) || (vs2 & 1)) {
+    if (((vs1 & 1) || (vs2 & 1) )) {
         goto TryRead;
     }
 
@@ -499,7 +474,7 @@ TryRead:
 
     end_read_counter2(h, i1, i2, ve1, ve2);
 
-    if ((vs1 != ve1) || (vs2 != ve2)) {
+    if (((vs1 != ve1) || (vs2 != ve2))) {
         goto TryRead;
     }
 
@@ -667,18 +642,18 @@ cuckoo_status cuckoo_insert(cuckoo_hashtable_t* h,
     size_t i2   = _alt_index(h, hv, i1);
 
     ValType oldval;
-    cuckoo_status st;
-
-    st = _cuckoo_find(h, key, (char*) &oldval, i1, i2);
+    cuckoo_status st = _cuckoo_find(h, key, (char*) &oldval, i1, i2);
     if  (st == ok) {
         mutex_unlock(&h->lock);
         return failure_key_duplicated;
     }
 
-    st =  _cuckoo_insert(h, key, val, i1, i2);
+    st = _cuckoo_insert(h, key, val, i1, i2);
 
     if (h->expanding) {
-        // still some work to do
+        //
+        // still some work to do before releasing the lock
+        //
         _cuckoo_clean(h, DEFAULT_BULK_CLEAN);
     }
 
@@ -696,9 +671,7 @@ cuckoo_status cuckoo_delete(cuckoo_hashtable_t* h,
     size_t i1   = _index_hash(h, hv);
     size_t i2   = _alt_index(h, hv, i1);
 
-    cuckoo_status st;
-
-    st = _cuckoo_delete(h, key, i1, i2);
+    cuckoo_status st = _cuckoo_delete(h, key, i1, i2);
 
     mutex_unlock(&h->lock);
 

commit d144fc5ecf14047bfb86a38233ffb57e12a782bc
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Sun Apr 28 21:02:13 2013 -0400

    remove valid bit

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index 6003b74..089b386 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -38,9 +38,8 @@
  */
 #define bucketsize 4
 typedef struct {
-    uint8_t   valid;
-    KeyType keys[bucketsize * 2];
-    ValType vals[bucketsize * 2];
+    KeyType keys[bucketsize];
+    ValType vals[bucketsize];
 }  __attribute__((__packed__))
 Bucket;
 
@@ -140,7 +139,7 @@ static inline  uint32_t _hashed_key(const char* key) {
 #define hashsize(n) ((uint32_t) 1 << n)
 #define hashmask(n) (hashsize(n) - 1)
 
-#define tablesize(h)  (hashsize(h->hashpower) * sizeof(Bucket) / 2)
+#define tablesize(h)  (hashsize(h->hashpower) * sizeof(Bucket))
 
 
 /**
@@ -188,28 +187,18 @@ static inline size_t _alt_index(cuckoo_hashtable_t* h,
 /* } */
 
 
-#define TABLE_KEY(h, i, j) ((Bucket*) h->buckets)[i >> 1].keys[bucketsize * (i & 1) + j]
-#define TABLE_VAL(h, i, j) ((Bucket*) h->buckets)[i >> 1].vals[bucketsize * (i & 1) + j]
+#define TABLE_KEY(h, i, j) ((Bucket*) h->buckets)[i].keys[j]
+#define TABLE_VAL(h, i, j) ((Bucket*) h->buckets)[i].vals[j]
 
-static uint8_t valid_op[] = {0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
-static uint8_t invalid_op[] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};
+//static uint8_t valid_op[] = {0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
+//static uint8_t invalid_op[] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};
 
-#define SLOT_VALIDATE(h, i, j)                                   \
-    do {                                                    \
-        size_t offset = bucketsize * (i & 1) + j;           \
-        ((Bucket*) h->buckets)[i >> 1].valid |= valid_op[offset]; \
+#define SLOT_CLEAN(h, i, j)                \
+    do {                                        \
+        TABLE_KEY(h, i, j) = 0;                 \
     } while(0)
 
-#define SLOT_INVALIDATE(h, i, j)                                 \
-    do {                                                    \
-        size_t offset = bucketsize * (i & 1) + j;           \
-        ((Bucket*) h->buckets)[i >> 1].valid &= invalid_op[offset]; \
-    } while(0)
-
-#define IS_SLOT_VALID(h, i, j)                                   \
-    ((((Bucket*) h->buckets)[i >> 1].valid) & valid_op[bucketsize * (i & 1) + j]) == 0
-
-
+#define IS_SLOT_AVAILABLE(h, i, j)   (TABLE_KEY(h, i, j) == 0)
 
 
 
@@ -221,7 +210,7 @@ static inline bool is_slot_empty(cuckoo_hashtable_t* h,
     /*     return true; */
     /* } */
 
-    if (IS_SLOT_VALID(h, i, j)) {
+    if (IS_SLOT_AVAILABLE(h, i, j)) {
         return true;
     }
 
@@ -233,8 +222,7 @@ static inline bool is_slot_empty(cuckoo_hashtable_t* h,
         size_t i2 = _alt_index(h, hv, i1);
         if ((i != i1) && (i != i2)) {
 
-            SLOT_INVALIDATE(h, i, j);
-            //TABLE_KEY(h, i, j)=0;
+            SLOT_CLEAN(h, i, j);
             return true;
         }
     }
@@ -343,11 +331,7 @@ static int _cuckoopath_move(cuckoo_hashtable_t* h,
         TABLE_KEY(h, i2, j2) = TABLE_KEY(h, i1, j1);
         TABLE_VAL(h, i2, j2) = TABLE_VAL(h, i1, j1);
 
-        SLOT_VALIDATE(h, i2, j2);
-        SLOT_INVALIDATE(h, i1, j1);
-
-        /* TABLE_KEY(h, i1, j1) = 0; */
-        /* TABLE_VAL(h, i1, j1) = 0; */
+        SLOT_CLEAN(h, i1, j1);
 
         end_incr_counter2(h, i1, i2);
 
@@ -445,8 +429,6 @@ static bool _try_add_to_bucket(cuckoo_hashtable_t* h,
             memcpy(&TABLE_KEY(h, i, j), key, sizeof(KeyType));
             memcpy(&TABLE_VAL(h, i, j), val, sizeof(ValType));
 
-            SLOT_VALIDATE(h, i, j);
-
             end_incr_counter(h, i);
             h->hashitems++;
             return true;
@@ -474,7 +456,7 @@ static bool _try_del_from_bucket(cuckoo_hashtable_t* h,
         if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
 
             start_incr_counter(h, i);
-            SLOT_INVALIDATE(h, i, j);
+            SLOT_CLEAN(h, i, j);
             end_incr_counter(h, i);
 
             h->hashitems --;
@@ -585,7 +567,7 @@ static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
     for (size_t ii = 0; ii < size; ii++) {
         size_t i = h->cleaned_buckets;
         for (size_t j = 0; j < bucketsize; j++) {
-            if (TABLE_KEY(h, i, j) == 0) {
+            if (IS_SLOT_AVAILABLE(h, i, j) == 0) {
                 continue;
             }
             uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
@@ -593,7 +575,7 @@ static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
             size_t i2 = _alt_index(h, hv, i1);
             if ((i != i1) && (i != i2)) {
                 //DBG("delete key %u , i=%zu i1=%zu i2=%zu\n", TABLE_KEY(h, i, j), i, i1, i2);
-                SLOT_INVALIDATE(h, i, j);
+                SLOT_CLEAN(h, i, j);
             }
         }
         h->cleaned_buckets++;

commit 9ac65f9f29a587faad432ffb0e217bfd2b944282
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Sun Apr 28 18:31:16 2013 -0400

    change key-based version counter to bucket based

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index 0575b08..6003b74 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -26,8 +26,11 @@
  */
 #define NUM_CUCKOO_PATH 2
 
-#define  keyver_count ((uint32_t)1 << (13))
-#define  keyver_mask  (keyver_count - 1)
+/*
+ * The array of version counter
+ */
+#define  counter_size  ((uint32_t)1 << (13))
+#define  counter_mask  (counter_size - 1)
 
 
 /*
@@ -41,53 +44,88 @@ typedef struct {
 }  __attribute__((__packed__))
 Bucket;
 
-
-/* /\** */
-/*  *  @brief Atomic read the counter */
-/*  * */
-/*  *\/ */
+// the old code
 /* #define read_keyver(h, idx)                                      \ */
 /*     __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 0) */
 
-/* /\** */
-/*  * @brief Atomic increase the counter */
-/*  * */
-/*  *\/ */
 /* #define incr_keyver(h, idx)                                      \ */
 /*     __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 1) */
 
+#define likely(x)     __builtin_expect(!!(x), 1)
+#define unlikely(x)   __builtin_expect(!!(x), 0)
+
 /**
  *  @brief read the counter, ensured by x86 memory ordering model
  *
  */
-#define start_read_keyver(h, idx, result)                               \
+#define start_read_counter(h, idx, version)                             \
+    do {                                                                \
+        version = *(volatile uint32_t *)(&((uint32_t*) h->counters)[idx & counter_mask]); \
+        __asm__ __volatile__("" ::: "memory");                          \
+    } while(0)
+
+#define end_read_counter(h, idx, version)                               \
     do {                                                                \
-        result = *(volatile uint32_t *)(&((uint32_t*) h->keyver_array)[idx & keyver_mask]); \
+        __asm__ __volatile__("" ::: "memory");                          \
+        version = *(volatile uint32_t *)(&((uint32_t*) h->counters)[idx & counter_mask]); \
+    } while (0)
+
+
+#define start_read_counter2(h, i1, i2, v1, v2)                          \
+    do {                                                                \
+        v1 = *(volatile uint32_t *)(&((uint32_t*) h->counters)[i1 & counter_mask]); \
+        v2 = *(volatile uint32_t *)(&((uint32_t*) h->counters)[i2 & counter_mask]); \
         __asm__ __volatile__("" ::: "memory");                          \
     } while(0)
 
-#define end_read_keyver(h, idx, result)                                 \
+#define end_read_counter2(h, i1, i2, v1, v2)                            \
     do {                                                                \
         __asm__ __volatile__("" ::: "memory");                          \
-        result = *(volatile uint32_t *)(&((uint32_t*) h->keyver_array)[idx & keyver_mask]); \
+        v1 = *(volatile uint32_t *)(&((uint32_t*) h->counters)[i1 & counter_mask]); \
+        v2 = *(volatile uint32_t *)(&((uint32_t*) h->counters)[i2 & counter_mask]); \
     } while (0)
 
+
 /**
  * @brief Atomic increase the counter
  *
  */
-#define start_incr_keyver(h, idx)                                       \
+#define start_incr_counter(h, idx)                                  \
+    do {                                                            \
+        ((volatile uint32_t *)h->counters)[idx & counter_mask]++;   \
+        __asm__ __volatile__("" ::: "memory");                      \
+    } while(0)
+
+#define end_incr_counter(h, idx)                                    \
+    do {                                                            \
+        __asm__ __volatile__("" ::: "memory");                      \
+        ((volatile uint32_t*) h->counters)[idx & counter_mask]++;   \
+    } while(0)
+
+
+#define start_incr_counter2(h, i1, i2)                                  \
     do {                                                                \
-        ((volatile uint32_t *)h->keyver_array)[idx & keyver_mask] += 1; \
+        if (likely((i1 & counter_mask) != (i2 & counter_mask))) {       \
+            ((volatile uint32_t *)h->counters)[i1 & counter_mask]++;    \
+            ((volatile uint32_t *)h->counters)[i2 & counter_mask]++;    \
+        } else {                                                        \
+            ((volatile uint32_t *)h->counters)[i1 & counter_mask]++;    \
+        }                                                               \
         __asm__ __volatile__("" ::: "memory");                          \
     } while(0)
 
-#define end_incr_keyver(h, idx)                                         \
+#define end_incr_counter2(h, i1, i2)                                    \
     do {                                                                \
         __asm__ __volatile__("" ::: "memory");                          \
-        ((volatile uint32_t*) h->keyver_array)[idx & keyver_mask] += 1; \
+        if (likely((i1 & counter_mask) != (i2 & counter_mask))) {     \
+            ((volatile uint32_t *)h->counters)[i1 & counter_mask]++;    \
+            ((volatile uint32_t *)h->counters)[i2 & counter_mask]++;    \
+        } else {                                                        \
+            ((volatile uint32_t *)h->counters)[i1 & counter_mask]++;    \
+        }                                                               \
     } while(0)
 
+
 // dga does not thing we need this mfence in end_incr, because
 // the current code will call pthread_mutex_unlock before returning
 // to the caller;  pthread_mutex_unlock is a memory barrier:
@@ -145,9 +183,9 @@ static inline size_t _alt_index(cuckoo_hashtable_t* h,
  *
  * @return The index of the counter
  */
-static inline size_t _lock_index(const uint32_t hv) {
-    return hv & keyver_mask;
-}
+/* static inline size_t _lock_index(const uint32_t hv) { */
+/*     return hv & keyver_mask; */
+/* } */
 
 
 #define TABLE_KEY(h, i, j) ((Bucket*) h->buckets)[i >> 1].keys[bucketsize * (i & 1) + j]
@@ -300,10 +338,7 @@ static int _cuckoopath_move(cuckoo_hashtable_t* h,
 
         //assert(is_slot_empty(h, i2, j2));
 
-        uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i1, j1));
-        size_t keylock   = _lock_index(hv);
-
-        start_incr_keyver(h, keylock);
+        start_incr_counter2(h, i1, i2);
 
         TABLE_KEY(h, i2, j2) = TABLE_KEY(h, i1, j1);
         TABLE_VAL(h, i2, j2) = TABLE_VAL(h, i1, j1);
@@ -314,7 +349,7 @@ static int _cuckoopath_move(cuckoo_hashtable_t* h,
         /* TABLE_KEY(h, i1, j1) = 0; */
         /* TABLE_VAL(h, i1, j1) = 0; */
 
-        end_incr_keyver(h, keylock);
+        end_incr_counter2(h, i1, i2);
 
         depth --;
     }
@@ -395,26 +430,24 @@ static bool _try_read_from_bucket(cuckoo_hashtable_t* h,
  * @param key Pointer to the key to store
  * @param val Pointer to the value to store
  * @param i Bucket index
- * @param keylock The index of key version counter
  *
  * @return true on success and false on failure
  */
 static bool _try_add_to_bucket(cuckoo_hashtable_t* h,
                                const char* key,
                                const char* val,
-                               size_t i,
-                               size_t keylock) {
+                               size_t i) {
     for (size_t j = 0; j < bucketsize; j++) {
         if (is_slot_empty(h, i, j)) {
 
-            start_incr_keyver(h, keylock);
+            start_incr_counter(h, i);
 
             memcpy(&TABLE_KEY(h, i, j), key, sizeof(KeyType));
             memcpy(&TABLE_VAL(h, i, j), val, sizeof(ValType));
 
             SLOT_VALIDATE(h, i, j);
 
-            end_incr_keyver(h, keylock);
+            end_incr_counter(h, i);
             h->hashitems++;
             return true;
         }
@@ -430,25 +463,20 @@ static bool _try_add_to_bucket(cuckoo_hashtable_t* h,
  *
  * @param key Pointer to the key to store
  * @param i Bucket index
- * @param keylock The index of key version counter
 
  * @return true if key is found, false otherwise
  */
 static bool _try_del_from_bucket(cuckoo_hashtable_t* h,
                                  const char*key,
-                                 size_t i,
-                                 size_t keylock) {
+                                 size_t i) {
     for (size_t j = 0; j < bucketsize; j++) {
 
         if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
 
-            start_incr_keyver(h, keylock);
-
+            start_incr_counter(h, i);
             SLOT_INVALIDATE(h, i, j);
-            /* TABLE_KEY(h, i, j) = 0; */
-            /* TABLE_VAL(h, i, j) = 0; */
+            end_incr_counter(h, i);
 
-            end_incr_keyver(h, keylock);
             h->hashitems --;
             return true;
         }
@@ -464,7 +492,6 @@ static bool _try_del_from_bucket(cuckoo_hashtable_t* h,
  * @param val
  * @param i1
  * @param i2
- * @param keylock
  *
  * @return
  */
@@ -472,22 +499,25 @@ static cuckoo_status _cuckoo_find(cuckoo_hashtable_t* h,
                                   const char *key,
                                   char *val,
                                   size_t i1,
-                                  size_t i2,
-                                  size_t keylock) {
+                                  size_t i2) {
     bool result;
 
-    uint32_t vs, ve;
+    uint32_t vs1, vs2, ve1, ve2;
 TryRead:
-    start_read_keyver(h, keylock, vs);
+    start_read_counter2(h, i1, i2, vs1, vs2);
+
+    if ((vs1 & 1) || (vs2 & 1)) {
+        goto TryRead;
+    }
 
     result = _try_read_from_bucket(h, key, val, i1);
     if (!result) {
         result = _try_read_from_bucket(h, key, val, i2);
     }
 
-    end_read_keyver(h, keylock, ve);
+    end_read_counter2(h, i1, i2, ve1, ve2);
 
-    if (vs & 1 || vs != ve) {
+    if ((vs1 != ve1) || (vs2 != ve2)) {
         goto TryRead;
     }
 
@@ -502,17 +532,16 @@ static cuckoo_status _cuckoo_insert(cuckoo_hashtable_t* h,
                                     const char* key,
                                     const char* val,
                                     size_t i1,
-                                    size_t i2,
-                                    size_t keylock) {
+                                    size_t i2) {
 
     /*
      * try to add new key to bucket i1 first, then try bucket i2
      */
-    if (_try_add_to_bucket(h, key, val, i1, keylock)) {
+    if (_try_add_to_bucket(h, key, val, i1)) {
         return ok;
     }
 
-    if (_try_add_to_bucket(h, key, val, i2, keylock)) {
+    if (_try_add_to_bucket(h, key, val, i2)) {
         return ok;
     }
 
@@ -523,7 +552,7 @@ static cuckoo_status _cuckoo_insert(cuckoo_hashtable_t* h,
     size_t i = 0;
             
     if (_run_cuckoo(h, i1, i2, &i)) {
-        if (_try_add_to_bucket(h, key, val, i, keylock)) {
+        if (_try_add_to_bucket(h, key, val, i)) {
             return ok;
         }
     }
@@ -539,13 +568,12 @@ static cuckoo_status _cuckoo_insert(cuckoo_hashtable_t* h,
 static cuckoo_status _cuckoo_delete(cuckoo_hashtable_t* h,
                                     const char* key,
                                     size_t i1,
-                                    size_t i2,
-                                    size_t keylock) {
-    if (_try_del_from_bucket(h, key, i1, keylock)) {
+                                    size_t i2) {
+    if (_try_del_from_bucket(h, key, i1)) {
         return ok;
     }
 
-    if (_try_del_from_bucket(h, key, i2, keylock)) {
+    if (_try_del_from_bucket(h, key, i2)) {
         return ok;
     }
 
@@ -565,10 +593,7 @@ static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
             size_t i2 = _alt_index(h, hv, i1);
             if ((i != i1) && (i != i2)) {
                 //DBG("delete key %u , i=%zu i1=%zu i2=%zu\n", TABLE_KEY(h, i, j), i, i1, i2);
-
-                SLOT_INVALIDATE(h, i, h);
-                /* TABLE_KEY(h, i, j) = 0; */
-                /* TABLE_VAL(h, i, j) = 0; */
+                SLOT_INVALIDATE(h, i, j);
             }
         }
         h->cleaned_buckets++;
@@ -603,21 +628,21 @@ cuckoo_hashtable_t* cuckoo_init(const int hashtable_init) {
         goto Cleanup;
     }
 
-    h->keyver_array = malloc(keyver_count * sizeof(uint32_t));
-    if (! h->keyver_array) {
-        fprintf(stderr, "Failed to init key version array.\n");
+    h->counters = malloc(counter_size * sizeof(uint32_t));
+    if (! h->counters) {
+        fprintf(stderr, "Failed to init counter array.\n");
         goto Cleanup;
     }
 
 
     memset(h->buckets, 0, tablesize(h));
-    memset(h->keyver_array, 0, keyver_count * sizeof(uint32_t));
+    memset(h->counters, 0, counter_size * sizeof(uint32_t));
 
     return h;
 
 Cleanup:
     if (h) {
-        free(h->keyver_array);
+        free(h->counters);
         free(h->buckets);
     }
     free(h);
@@ -628,7 +653,7 @@ Cleanup:
 cuckoo_status cuckoo_exit(cuckoo_hashtable_t* h) {
     pthread_mutex_destroy(&h->lock);
     free(h->buckets);
-    free(h->keyver_array);
+    free(h->counters);
     free(h);
     return ok;
 }
@@ -640,9 +665,8 @@ cuckoo_status cuckoo_find(cuckoo_hashtable_t* h,
     uint32_t hv    = _hashed_key(key);
     size_t i1      = _index_hash(h, hv);
     size_t i2      = _alt_index(h, hv, i1);
-    size_t keylock = _lock_index(hv);
 
-    cuckoo_status st = _cuckoo_find(h, key, val, i1, i2, keylock);
+    cuckoo_status st = _cuckoo_find(h, key, val, i1, i2);
 
     if (st == failure_key_not_found) {
         DBG("miss for key %u i1=%zu i2=%zu hv=%u\n", *((KeyType*) key), i1, i2, hv);
@@ -659,18 +683,17 @@ cuckoo_status cuckoo_insert(cuckoo_hashtable_t* h,
     uint32_t hv = _hashed_key(key);
     size_t i1   = _index_hash(h, hv);
     size_t i2   = _alt_index(h, hv, i1);
-    size_t keylock = _lock_index(hv);
 
     ValType oldval;
     cuckoo_status st;
 
-    st = _cuckoo_find(h, key, (char*) &oldval, i1, i2, keylock);
+    st = _cuckoo_find(h, key, (char*) &oldval, i1, i2);
     if  (st == ok) {
         mutex_unlock(&h->lock);
         return failure_key_duplicated;
     }
 
-    st =  _cuckoo_insert(h, key, val, i1, i2, keylock);
+    st =  _cuckoo_insert(h, key, val, i1, i2);
 
     if (h->expanding) {
         // still some work to do
@@ -690,11 +713,10 @@ cuckoo_status cuckoo_delete(cuckoo_hashtable_t* h,
     uint32_t hv = _hashed_key(key);
     size_t i1   = _index_hash(h, hv);
     size_t i2   = _alt_index(h, hv, i1);
-    size_t keylock = _lock_index(hv);
 
     cuckoo_status st;
 
-    st = _cuckoo_delete(h, key, i1, i2, keylock);
+    st = _cuckoo_delete(h, key, i1, i2);
 
     mutex_unlock(&h->lock);
 

commit f7a045319f752d248e90e4038177898035fe7ea4
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Fri Apr 26 14:45:27 2013 -0400

    add valid bit to each slot

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index 6b1227a..0575b08 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -31,12 +31,13 @@
 
 
 /*
- * the structure of a bucket
+ * the structure of every two buckets
  */
 #define bucketsize 4
 typedef struct {
-    KeyType keys[bucketsize];
-    ValType vals[bucketsize];
+    uint8_t   valid;
+    KeyType keys[bucketsize * 2];
+    ValType vals[bucketsize * 2];
 }  __attribute__((__packed__))
 Bucket;
 
@@ -91,7 +92,7 @@ Bucket;
 // the current code will call pthread_mutex_unlock before returning
 // to the caller;  pthread_mutex_unlock is a memory barrier:
 // http://www.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_11
-// __asm__ __volatile("mfence" ::: "memory");                      \
+// __asm__ __volatile("mfence" ::: "memory");                     
 
 
 static inline  uint32_t _hashed_key(const char* key) {
@@ -101,6 +102,7 @@ static inline  uint32_t _hashed_key(const char* key) {
 #define hashsize(n) ((uint32_t) 1 << n)
 #define hashmask(n) (hashsize(n) - 1)
 
+#define tablesize(h)  (hashsize(h->hashpower) * sizeof(Bucket) / 2)
 
 
 /**
@@ -148,15 +150,40 @@ static inline size_t _lock_index(const uint32_t hv) {
 }
 
 
-#define TABLE_KEY(h, i, j) ((Bucket*) h->buckets)[i].keys[j]
-#define TABLE_VAL(h, i, j) ((Bucket*) h->buckets)[i].vals[j]
+#define TABLE_KEY(h, i, j) ((Bucket*) h->buckets)[i >> 1].keys[bucketsize * (i & 1) + j]
+#define TABLE_VAL(h, i, j) ((Bucket*) h->buckets)[i >> 1].vals[bucketsize * (i & 1) + j]
+
+static uint8_t valid_op[] = {0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
+static uint8_t invalid_op[] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};
+
+#define SLOT_VALIDATE(h, i, j)                                   \
+    do {                                                    \
+        size_t offset = bucketsize * (i & 1) + j;           \
+        ((Bucket*) h->buckets)[i >> 1].valid |= valid_op[offset]; \
+    } while(0)
+
+#define SLOT_INVALIDATE(h, i, j)                                 \
+    do {                                                    \
+        size_t offset = bucketsize * (i & 1) + j;           \
+        ((Bucket*) h->buckets)[i >> 1].valid &= invalid_op[offset]; \
+    } while(0)
+
+#define IS_SLOT_VALID(h, i, j)                                   \
+    ((((Bucket*) h->buckets)[i >> 1].valid) & valid_op[bucketsize * (i & 1) + j]) == 0
+
+
+
 
 
 //#define IS_SLOT_EMPTY(h, i, j) (TABLE_KEY(h, i, j)==0)
 static inline bool is_slot_empty(cuckoo_hashtable_t* h,
                                  size_t i,
                                  size_t j) {
-    if (TABLE_KEY(h, i, j)==0) {
+    /* if (TABLE_KEY(h, i, j)==0) { */
+    /*     return true; */
+    /* } */
+
+    if (IS_SLOT_VALID(h, i, j)) {
         return true;
     }
 
@@ -167,7 +194,9 @@ static inline bool is_slot_empty(cuckoo_hashtable_t* h,
         size_t i1 = _index_hash(h, hv);
         size_t i2 = _alt_index(h, hv, i1);
         if ((i != i1) && (i != i2)) {
-            TABLE_KEY(h, i, j)=0;
+
+            SLOT_INVALIDATE(h, i, j);
+            //TABLE_KEY(h, i, j)=0;
             return true;
         }
     }
@@ -278,8 +307,12 @@ static int _cuckoopath_move(cuckoo_hashtable_t* h,
 
         TABLE_KEY(h, i2, j2) = TABLE_KEY(h, i1, j1);
         TABLE_VAL(h, i2, j2) = TABLE_VAL(h, i1, j1);
-        TABLE_KEY(h, i1, j1) = 0;
-        TABLE_VAL(h, i1, j1) = 0;
+
+        SLOT_VALIDATE(h, i2, j2);
+        SLOT_INVALIDATE(h, i1, j1);
+
+        /* TABLE_KEY(h, i1, j1) = 0; */
+        /* TABLE_VAL(h, i1, j1) = 0; */
 
         end_incr_keyver(h, keylock);
 
@@ -379,6 +412,8 @@ static bool _try_add_to_bucket(cuckoo_hashtable_t* h,
             memcpy(&TABLE_KEY(h, i, j), key, sizeof(KeyType));
             memcpy(&TABLE_VAL(h, i, j), val, sizeof(ValType));
 
+            SLOT_VALIDATE(h, i, j);
+
             end_incr_keyver(h, keylock);
             h->hashitems++;
             return true;
@@ -409,8 +444,9 @@ static bool _try_del_from_bucket(cuckoo_hashtable_t* h,
 
             start_incr_keyver(h, keylock);
 
-            TABLE_KEY(h, i, j) = 0;
-            TABLE_VAL(h, i, j) = 0;
+            SLOT_INVALIDATE(h, i, j);
+            /* TABLE_KEY(h, i, j) = 0; */
+            /* TABLE_VAL(h, i, j) = 0; */
 
             end_incr_keyver(h, keylock);
             h->hashitems --;
@@ -530,8 +566,9 @@ static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
             if ((i != i1) && (i != i2)) {
                 //DBG("delete key %u , i=%zu i1=%zu i2=%zu\n", TABLE_KEY(h, i, j), i, i1, i2);
 
-                TABLE_KEY(h, i, j) = 0;
-                TABLE_VAL(h, i, j) = 0;
+                SLOT_INVALIDATE(h, i, h);
+                /* TABLE_KEY(h, i, j) = 0; */
+                /* TABLE_VAL(h, i, j) = 0; */
             }
         }
         h->cleaned_buckets++;
@@ -560,7 +597,7 @@ cuckoo_hashtable_t* cuckoo_init(const int hashtable_init) {
     h->expanding  = false;
     pthread_mutex_init(&h->lock, NULL);
 
-    h->buckets = malloc(hashsize(h->hashpower) * sizeof(Bucket));
+    h->buckets = malloc(tablesize(h));
     if (! h->buckets) {
         fprintf(stderr, "Failed to init hashtable.\n");
         goto Cleanup;
@@ -573,7 +610,7 @@ cuckoo_hashtable_t* cuckoo_init(const int hashtable_init) {
     }
 
 
-    memset(h->buckets, 0, hashsize(h->hashpower) * sizeof(Bucket));
+    memset(h->buckets, 0, tablesize(h));
     memset(h->keyver_array, 0, keyver_count * sizeof(uint32_t));
 
     return h;
@@ -676,15 +713,16 @@ cuckoo_status cuckoo_expand(cuckoo_hashtable_t* h) {
     h->expanding = true;
 
     Bucket* old_buckets = (Bucket*) h->buckets;
-    Bucket* new_buckets = (Bucket*) malloc(hashsize((h->hashpower + 1)) * sizeof(Bucket));
+    Bucket* new_buckets = (Bucket*) malloc(tablesize(h) * 2);
     if (!new_buckets) {
         h->expanding = false;
         mutex_unlock(&h->lock);
         return failure_space_not_enough;
     }
 
-    memcpy(new_buckets, h->buckets, hashsize(h->hashpower) * sizeof(Bucket));
-    memcpy(new_buckets + hashsize(h->hashpower), h->buckets, hashsize(h->hashpower) * sizeof(Bucket));
+
+    memcpy(new_buckets, h->buckets, tablesize(h));
+    memcpy(new_buckets + tablesize(h), h->buckets, tablesize(h));
 
 
     h->buckets = new_buckets;
@@ -703,10 +741,8 @@ cuckoo_status cuckoo_expand(cuckoo_hashtable_t* h) {
 
 void cuckoo_report(cuckoo_hashtable_t* h) {
 
-    size_t sz;
-    sz = sizeof(Bucket) * hashsize(h->hashpower);
     DBG("total number of items %zu\n", h->hashitems);
-    DBG("total size %zu Bytes, or %.2f MB\n", sz, (float) sz / (1 <<20));
+    DBG("total size %zu Bytes, or %.2f MB\n", tablesize(h), (float) tablesize(h) / (1 <<20));
     DBG("load factor %.4f\n", 1.0 * h->hashitems / bucketsize / hashsize(h->hashpower));
 }
 

commit c2c22a1b3e63b2d38e21106d70f81bb4aeeb18b8
Author: Dave Andersen <dga@cs.cmu.edu>
Date:   Fri Apr 26 10:44:24 2013 -0400

    Changed my mind back, but now I have a reason for it. :-)

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index b2a50ab..6b1227a 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -85,9 +85,14 @@ Bucket;
     do {                                                                \
         __asm__ __volatile__("" ::: "memory");                          \
         ((volatile uint32_t*) h->keyver_array)[idx & keyver_mask] += 1; \
-	__asm__ __volatile("mfence" ::: "memory");                      \
     } while(0)
 
+// dga does not thing we need this mfence in end_incr, because
+// the current code will call pthread_mutex_unlock before returning
+// to the caller;  pthread_mutex_unlock is a memory barrier:
+// http://www.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_11
+// __asm__ __volatile("mfence" ::: "memory");                      \
+
 
 static inline  uint32_t _hashed_key(const char* key) {
     return CityHash32(key, sizeof(KeyType));

commit d537eca730fdddb914fe83e4580bda023de404ff
Author: Dave Andersen <dga@cs.cmu.edu>
Date:   Fri Apr 26 10:41:04 2013 -0400

    Slowing things down a little to have a slightly safer consistency model.

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index ef7833c..b2a50ab 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -85,6 +85,7 @@ Bucket;
     do {                                                                \
         __asm__ __volatile__("" ::: "memory");                          \
         ((volatile uint32_t*) h->keyver_array)[idx & keyver_mask] += 1; \
+	__asm__ __volatile("mfence" ::: "memory");                      \
     } while(0)
 
 

commit d04b48aeda4ad32137c83f69dbad1bde39c8f34f
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Thu Apr 25 22:31:50 2013 -0400

    cleaning up some code

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index 30c6c8e..ef7833c 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -56,33 +56,35 @@ Bucket;
 /*     __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 1) */
 
 /**
- *  @brief Atomic read the counter
+ *  @brief read the counter, ensured by x86 memory ordering model
  *
  */
-#define start_read_keyver(h, idx, result)                                   \
-    do { \
-      result = *(volatile uint32_t *)(&((uint32_t*) h->keyver_array)[idx & keyver_mask]); \
-      __asm__ __volatile__("" ::: "memory"); \
+#define start_read_keyver(h, idx, result)                               \
+    do {                                                                \
+        result = *(volatile uint32_t *)(&((uint32_t*) h->keyver_array)[idx & keyver_mask]); \
+        __asm__ __volatile__("" ::: "memory");                          \
     } while(0)
 
-#define end_read_keyver(h, idx, result)                                \
-    do { __asm__ __volatile__("" ::: "memory");  \
-      result = *(volatile uint32_t *)(&((uint32_t*) h->keyver_array)[idx & keyver_mask]); \
+#define end_read_keyver(h, idx, result)                                 \
+    do {                                                                \
+        __asm__ __volatile__("" ::: "memory");                          \
+        result = *(volatile uint32_t *)(&((uint32_t*) h->keyver_array)[idx & keyver_mask]); \
     } while (0)
 
 /**
  * @brief Atomic increase the counter
  *
  */
-#define start_incr_keyver(h, idx)                                      \
-    do { ((volatile uint32_t *)h->keyver_array)[idx & keyver_mask] += 1; \
-    __asm__ __volatile__("" ::: "memory"); \
-       } while(0)
-
-#define end_incr_keyver(h, idx)                                      \
-    do { \
-    __asm__ __volatile__("" ::: "memory"); \
-    ((volatile uint32_t*) h->keyver_array)[idx & keyver_mask] += 1; \
+#define start_incr_keyver(h, idx)                                       \
+    do {                                                                \
+        ((volatile uint32_t *)h->keyver_array)[idx & keyver_mask] += 1; \
+        __asm__ __volatile__("" ::: "memory");                          \
+    } while(0)
+
+#define end_incr_keyver(h, idx)                                         \
+    do {                                                                \
+        __asm__ __volatile__("" ::: "memory");                          \
+        ((volatile uint32_t*) h->keyver_array)[idx & keyver_mask] += 1; \
     } while(0)
 
 
@@ -148,8 +150,10 @@ static inline size_t _lock_index(const uint32_t hv) {
 static inline bool is_slot_empty(cuckoo_hashtable_t* h,
                                  size_t i,
                                  size_t j) {
-    if (TABLE_KEY(h, i, j)==0)
+    if (TABLE_KEY(h, i, j)==0) {
         return true;
+    }
+
     if (h->expanding) {
         // when we are expanding
         // we could leave keys in their old but wrong buckets
@@ -296,18 +300,20 @@ static bool _run_cuckoo(cuckoo_hashtable_t* h,
 
     size_t idx;
     for (idx = 0; idx < NUM_CUCKOO_PATH; idx++) {
-        if (idx < NUM_CUCKOO_PATH / 2)
+        if (idx < NUM_CUCKOO_PATH / 2) {
             cuckoo_path[0].buckets[idx] = i1;
-        else
+        } else {
             cuckoo_path[0].buckets[idx] = i2;
+        }
     }
 
     size_t num_kicks = 0;
     while (1) {
         int depth;
         depth = _cuckoopath_search(h, cuckoo_path, &idx, &num_kicks);
-        if (depth < 0) 
+        if (depth < 0) {
             break;
+        }
 
         int curr_depth = _cuckoopath_move(h, cuckoo_path, depth, idx);
         if (curr_depth == 0) {
@@ -334,8 +340,7 @@ static bool _try_read_from_bucket(cuckoo_hashtable_t* h,
                                   const char *key,
                                   char *val,
                                   size_t i) {
-    size_t  j;
-    for (j = 0; j < bucketsize; j++) {
+    for (size_t j = 0; j < bucketsize; j++) {
 
         if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
             memcpy(val, (char*) &TABLE_VAL(h, i, j), sizeof(ValType));
@@ -360,8 +365,7 @@ static bool _try_add_to_bucket(cuckoo_hashtable_t* h,
                                const char* val,
                                size_t i,
                                size_t keylock) {
-    size_t j;
-    for (j = 0; j < bucketsize; j++) {
+    for (size_t j = 0; j < bucketsize; j++) {
         if (is_slot_empty(h, i, j)) {
 
             start_incr_keyver(h, keylock);
@@ -369,9 +373,8 @@ static bool _try_add_to_bucket(cuckoo_hashtable_t* h,
             memcpy(&TABLE_KEY(h, i, j), key, sizeof(KeyType));
             memcpy(&TABLE_VAL(h, i, j), val, sizeof(ValType));
 
-            h->hashitems++;
-
             end_incr_keyver(h, keylock);
+            h->hashitems++;
             return true;
         }
     }
@@ -394,8 +397,7 @@ static bool _try_del_from_bucket(cuckoo_hashtable_t* h,
                                  const char*key,
                                  size_t i,
                                  size_t keylock) {
-    size_t j;
-    for (j = 0; j < bucketsize; j++) {
+    for (size_t j = 0; j < bucketsize; j++) {
 
         if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
 
@@ -403,12 +405,9 @@ static bool _try_del_from_bucket(cuckoo_hashtable_t* h,
 
             TABLE_KEY(h, i, j) = 0;
             TABLE_VAL(h, i, j) = 0;
-            /* buckets[i].keys[j] = 0; */
-            /* buckets[i].vals[j] = 0; */
-
-            h->hashitems --;
 
             end_incr_keyver(h, keylock);
+            h->hashitems --;
             return true;
         }
     }
@@ -446,13 +445,15 @@ TryRead:
 
     end_read_keyver(h, keylock, ve);
 
-    if (vs & 1 || vs != ve)
+    if (vs & 1 || vs != ve) {
         goto TryRead;
+    }
 
-    if (result)
+    if (result) {
         return ok;
-    else
+    } else {
         return failure_key_not_found;
+    }
 }
 
 static cuckoo_status _cuckoo_insert(cuckoo_hashtable_t* h,
@@ -465,11 +466,13 @@ static cuckoo_status _cuckoo_insert(cuckoo_hashtable_t* h,
     /*
      * try to add new key to bucket i1 first, then try bucket i2
      */
-    if (_try_add_to_bucket(h, key, val, i1, keylock))
+    if (_try_add_to_bucket(h, key, val, i1, keylock)) {
         return ok;
+    }
 
-    if (_try_add_to_bucket(h, key, val, i2, keylock))
+    if (_try_add_to_bucket(h, key, val, i2, keylock)) {
         return ok;
+    }
 
 
     /*
@@ -496,27 +499,26 @@ static cuckoo_status _cuckoo_delete(cuckoo_hashtable_t* h,
                                     size_t i1,
                                     size_t i2,
                                     size_t keylock) {
-    if (_try_del_from_bucket(h, key, i1, keylock))
+    if (_try_del_from_bucket(h, key, i1, keylock)) {
         return ok;
+    }
 
-    if (_try_del_from_bucket(h, key, i2, keylock))
+    if (_try_del_from_bucket(h, key, i2, keylock)) {
         return ok;
+    }
 
     return failure_key_not_found;
 
 }
 
 static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
-    size_t i, j, ii;
-
-    for (ii = 0; ii < size; ii++) {
-        i = h->cleaned_buckets;
-        uint32_t hv;
-        for (j = 0; j < bucketsize; j++) {
+    for (size_t ii = 0; ii < size; ii++) {
+        size_t i = h->cleaned_buckets;
+        for (size_t j = 0; j < bucketsize; j++) {
             if (TABLE_KEY(h, i, j) == 0) {
                 continue;
             }
-            hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
+            uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
             size_t i1 = _index_hash(h, hv);
             size_t i2 = _alt_index(h, hv, i1);
             if ((i != i1) && (i != i2)) {
@@ -543,8 +545,9 @@ static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
 
 cuckoo_hashtable_t* cuckoo_init(const int hashtable_init) {
     cuckoo_hashtable_t* h = (cuckoo_hashtable_t*) malloc(sizeof(cuckoo_hashtable_t));
-    if (!h)
+    if (!h) {
         goto Cleanup;
+    }
 
     h->hashpower  = (hashtable_init > 0) ? hashtable_init : HASHPOWER_DEFAULT;
     h->hashitems  = 0;

commit b9037bd9241158871fd85bbce6e847c10c9f4d99
Author: Dave Andersen <dga@cs.cmu.edu>
Date:   Thu Apr 25 21:39:17 2013 -0400

    Ok.  I *think* this code is correct on x86, but I'm scared of it.

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index 033d2fe..30c6c8e 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -59,12 +59,15 @@ Bucket;
  *  @brief Atomic read the counter
  *
  */
-#define start_read_keyver(h, idx, result)                                      \
-    result = __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 0)
+#define start_read_keyver(h, idx, result)                                   \
+    do { \
+      result = *(volatile uint32_t *)(&((uint32_t*) h->keyver_array)[idx & keyver_mask]); \
+      __asm__ __volatile__("" ::: "memory"); \
+    } while(0)
 
 #define end_read_keyver(h, idx, result)                                \
     do { __asm__ __volatile__("" ::: "memory");  \
-    result = ((uint32_t*) h->keyver_array)[idx & keyver_mask]; \
+      result = *(volatile uint32_t *)(&((uint32_t*) h->keyver_array)[idx & keyver_mask]); \
     } while (0)
 
 /**
@@ -72,13 +75,14 @@ Bucket;
  *
  */
 #define start_incr_keyver(h, idx)                                      \
-    do { ((uint32_t *)h->keyver_array)[idx & keyver_mask] += 1; \
+    do { ((volatile uint32_t *)h->keyver_array)[idx & keyver_mask] += 1; \
     __asm__ __volatile__("" ::: "memory"); \
        } while(0)
 
 #define end_incr_keyver(h, idx)                                      \
     do { \
-    __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 1); \
+    __asm__ __volatile__("" ::: "memory"); \
+    ((volatile uint32_t*) h->keyver_array)[idx & keyver_mask] += 1; \
     } while(0)
 
 

commit 309f4870a12a64f16e2b82e5f03f100d08a89032
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Thu Apr 25 18:58:14 2013 -0400

    add bench_cuckoo; and dave's change to remove 1/2 memory barrior

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index b5954b6..033d2fe 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -41,19 +41,45 @@ typedef struct {
 Bucket;
 
 
+/* /\** */
+/*  *  @brief Atomic read the counter */
+/*  * */
+/*  *\/ */
+/* #define read_keyver(h, idx)                                      \ */
+/*     __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 0) */
+
+/* /\** */
+/*  * @brief Atomic increase the counter */
+/*  * */
+/*  *\/ */
+/* #define incr_keyver(h, idx)                                      \ */
+/*     __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 1) */
+
 /**
  *  @brief Atomic read the counter
  *
  */
-#define read_keyver(h, idx)                                      \
-    __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 0)
+#define start_read_keyver(h, idx, result)                                      \
+    result = __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 0)
+
+#define end_read_keyver(h, idx, result)                                \
+    do { __asm__ __volatile__("" ::: "memory");  \
+    result = ((uint32_t*) h->keyver_array)[idx & keyver_mask]; \
+    } while (0)
 
 /**
  * @brief Atomic increase the counter
  *
  */
-#define incr_keyver(h, idx)                                      \
-    __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 1)
+#define start_incr_keyver(h, idx)                                      \
+    do { ((uint32_t *)h->keyver_array)[idx & keyver_mask] += 1; \
+    __asm__ __volatile__("" ::: "memory"); \
+       } while(0)
+
+#define end_incr_keyver(h, idx)                                      \
+    do { \
+    __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 1); \
+    } while(0)
 
 
 static inline  uint32_t _hashed_key(const char* key) {
@@ -234,14 +260,14 @@ static int _cuckoopath_move(cuckoo_hashtable_t* h,
         uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i1, j1));
         size_t keylock   = _lock_index(hv);
 
-        incr_keyver(h, keylock);
+        start_incr_keyver(h, keylock);
 
         TABLE_KEY(h, i2, j2) = TABLE_KEY(h, i1, j1);
         TABLE_VAL(h, i2, j2) = TABLE_VAL(h, i1, j1);
         TABLE_KEY(h, i1, j1) = 0;
         TABLE_VAL(h, i1, j1) = 0;
 
-        incr_keyver(h, keylock);
+        end_incr_keyver(h, keylock);
 
         depth --;
     }
@@ -334,14 +360,14 @@ static bool _try_add_to_bucket(cuckoo_hashtable_t* h,
     for (j = 0; j < bucketsize; j++) {
         if (is_slot_empty(h, i, j)) {
 
-            incr_keyver(h, keylock);
+            start_incr_keyver(h, keylock);
 
             memcpy(&TABLE_KEY(h, i, j), key, sizeof(KeyType));
             memcpy(&TABLE_VAL(h, i, j), val, sizeof(ValType));
 
             h->hashitems++;
 
-            incr_keyver(h, keylock);
+            end_incr_keyver(h, keylock);
             return true;
         }
     }
@@ -369,7 +395,7 @@ static bool _try_del_from_bucket(cuckoo_hashtable_t* h,
 
         if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
 
-            incr_keyver(h, keylock);
+            start_incr_keyver(h, keylock);
 
             TABLE_KEY(h, i, j) = 0;
             TABLE_VAL(h, i, j) = 0;
@@ -378,7 +404,7 @@ static bool _try_del_from_bucket(cuckoo_hashtable_t* h,
 
             h->hashitems --;
 
-            incr_keyver(h, keylock);
+            end_incr_keyver(h, keylock);
             return true;
         }
     }
@@ -407,14 +433,14 @@ static cuckoo_status _cuckoo_find(cuckoo_hashtable_t* h,
 
     uint32_t vs, ve;
 TryRead:
-    vs = read_keyver(h, keylock);
+    start_read_keyver(h, keylock, vs);
 
     result = _try_read_from_bucket(h, key, val, i1);
     if (!result) {
         result = _try_read_from_bucket(h, key, val, i2);
     }
 
-    ve = read_keyver(h, keylock);
+    end_read_keyver(h, keylock, ve);
 
     if (vs & 1 || vs != ve)
         goto TryRead;

commit eed1986dfa44062bd58f9141b431b0f9d190affb
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Fri Mar 8 22:36:37 2013 -0500

    address dave's comments on code. make access to total_inserted thread-safe

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index 42f5550..b5954b6 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -171,11 +171,11 @@ static int _cuckoopath_search(cuckoo_hashtable_t* h,
          * Check if any slot is already free
          */
         size_t idx;
-        for (idx = 0; idx < NUM_CUCKOO_PATH; idx ++) {
+        for (idx = 0; idx < NUM_CUCKOO_PATH; idx++) {
             size_t i;
             size_t j;
             i = curr->buckets[idx];
-            for (j = 0; j < bucketsize; j ++) {
+            for (j = 0; j < bucketsize; j++) {
                 if (is_slot_empty(h, i, j)) {
                     curr->slots[idx] = j;
                     *cp_index   = idx;
@@ -193,7 +193,7 @@ static int _cuckoopath_search(cuckoo_hashtable_t* h,
         }
 
         *num_kicks += NUM_CUCKOO_PATH;
-        depth ++;
+        depth++;
     }
 
     DBG("%zu max cuckoo achieved, abort\n", *num_kicks);
@@ -265,7 +265,7 @@ static bool _run_cuckoo(cuckoo_hashtable_t* h,
     memset(cuckoo_path, 0, MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
 
     size_t idx;
-    for (idx = 0; idx < NUM_CUCKOO_PATH; idx ++) {
+    for (idx = 0; idx < NUM_CUCKOO_PATH; idx++) {
         if (idx < NUM_CUCKOO_PATH / 2)
             cuckoo_path[0].buckets[idx] = i1;
         else
@@ -305,7 +305,7 @@ static bool _try_read_from_bucket(cuckoo_hashtable_t* h,
                                   char *val,
                                   size_t i) {
     size_t  j;
-    for (j = 0; j < bucketsize; j ++) {
+    for (j = 0; j < bucketsize; j++) {
 
         if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
             memcpy(val, (char*) &TABLE_VAL(h, i, j), sizeof(ValType));
@@ -331,7 +331,7 @@ static bool _try_add_to_bucket(cuckoo_hashtable_t* h,
                                size_t i,
                                size_t keylock) {
     size_t j;
-    for (j = 0; j < bucketsize; j ++) {
+    for (j = 0; j < bucketsize; j++) {
         if (is_slot_empty(h, i, j)) {
 
             incr_keyver(h, keylock);
@@ -339,7 +339,7 @@ static bool _try_add_to_bucket(cuckoo_hashtable_t* h,
             memcpy(&TABLE_KEY(h, i, j), key, sizeof(KeyType));
             memcpy(&TABLE_VAL(h, i, j), val, sizeof(ValType));
 
-            h->hashitems ++;
+            h->hashitems++;
 
             incr_keyver(h, keylock);
             return true;
@@ -365,7 +365,7 @@ static bool _try_del_from_bucket(cuckoo_hashtable_t* h,
                                  size_t i,
                                  size_t keylock) {
     size_t j;
-    for (j = 0; j < bucketsize; j ++) {
+    for (j = 0; j < bucketsize; j++) {
 
         if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
 
@@ -479,10 +479,10 @@ static cuckoo_status _cuckoo_delete(cuckoo_hashtable_t* h,
 static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
     size_t i, j, ii;
 
-    for (ii = 0; ii < size; ++ii) {
+    for (ii = 0; ii < size; ii++) {
         i = h->cleaned_buckets;
         uint32_t hv;
-        for (j = 0; j < bucketsize; j ++) {
+        for (j = 0; j < bucketsize; j++) {
             if (TABLE_KEY(h, i, j) == 0) {
                 continue;
             }
@@ -496,7 +496,7 @@ static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
                 TABLE_VAL(h, i, j) = 0;
             }
         }
-        h->cleaned_buckets ++;
+        h->cleaned_buckets++;
         if (h->cleaned_buckets == hashsize((h->hashpower))) {
             h->expanding = false;
             DBG("table clean done, cleaned_buckets = %zu\n", h->cleaned_buckets);
@@ -649,7 +649,7 @@ cuckoo_status cuckoo_expand(cuckoo_hashtable_t* h) {
 
 
     h->buckets = new_buckets;
-    h->hashpower ++;
+    h->hashpower++;
     h->cleaned_buckets = 0;
 
     //h->expanding = false;

commit 709653f73bc1e22e553361e856189580d6172ae6
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Fri Mar 8 20:29:27 2013 -0500

    make it working with Macos

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
new file mode 100644
index 0000000..42f5550
--- /dev/null
+++ b/lib/cuckoohash.c
@@ -0,0 +1,676 @@
+/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
+/**
+ * @file   cuckoohash.c
+ * @author Bin Fan <binfan@cs.cmu.edu>
+ * @date   Mon Feb 25 22:17:04 2013
+ *
+ * @brief  implementation of single-writer/multi-reader cuckoo hash
+ *
+ *
+ */
+
+#include "cuckoohash.h"
+
+/*
+ * default hash table size
+ */
+#define HASHPOWER_DEFAULT 16
+
+/*
+ * The maximum number of cuckoo operations per insert,
+ */
+#define MAX_CUCKOO_COUNT 500
+
+/*
+ * The number of cuckoo paths
+ */
+#define NUM_CUCKOO_PATH 2
+
+#define  keyver_count ((uint32_t)1 << (13))
+#define  keyver_mask  (keyver_count - 1)
+
+
+/*
+ * the structure of a bucket
+ */
+#define bucketsize 4
+typedef struct {
+    KeyType keys[bucketsize];
+    ValType vals[bucketsize];
+}  __attribute__((__packed__))
+Bucket;
+
+
+/**
+ *  @brief Atomic read the counter
+ *
+ */
+#define read_keyver(h, idx)                                      \
+    __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 0)
+
+/**
+ * @brief Atomic increase the counter
+ *
+ */
+#define incr_keyver(h, idx)                                      \
+    __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 1)
+
+
+static inline  uint32_t _hashed_key(const char* key) {
+    return CityHash32(key, sizeof(KeyType));
+}
+
+#define hashsize(n) ((uint32_t) 1 << n)
+#define hashmask(n) (hashsize(n) - 1)
+
+
+
+/**
+ * @brief Compute the index of the first bucket
+ *
+ * @param hv 32-bit hash value of the key
+ *
+ * @return The first bucket
+ */
+static inline size_t _index_hash(cuckoo_hashtable_t* h,
+                                 const uint32_t hv) {
+//    return  (hv >> (32 - h->hashpower));
+    return  (hv & hashmask(h->hashpower));
+}
+
+
+/**
+ * @brief Compute the index of the second bucket
+ *
+ * @param hv 32-bit hash value of the key
+ * @param index The index of the first bucket
+ *
+ * @return  The second bucket
+ */
+static inline size_t _alt_index(cuckoo_hashtable_t* h,
+                                const uint32_t hv,
+                                const size_t index) {
+    // 0x5bd1e995 is the hash constant from MurmurHash2
+    //uint32_t tag = hv & 0xFF;
+    uint32_t tag = hv >> 24;
+    return (index ^ (tag * 0x5bd1e995)) & hashmask(h->hashpower);
+    //return (hv ^ (tag * 0x5bd1e995)) & hashmask(h->hashpower);
+    //return ((hv >> 32) & hashmask(h->hashpower));
+}
+
+/**
+ * @brief Compute the index of the corresponding counter in keyver_array
+ *
+ * @param hv 32-bit hash value of the key
+ *
+ * @return The index of the counter
+ */
+static inline size_t _lock_index(const uint32_t hv) {
+    return hv & keyver_mask;
+}
+
+
+#define TABLE_KEY(h, i, j) ((Bucket*) h->buckets)[i].keys[j]
+#define TABLE_VAL(h, i, j) ((Bucket*) h->buckets)[i].vals[j]
+
+
+//#define IS_SLOT_EMPTY(h, i, j) (TABLE_KEY(h, i, j)==0)
+static inline bool is_slot_empty(cuckoo_hashtable_t* h,
+                                 size_t i,
+                                 size_t j) {
+    if (TABLE_KEY(h, i, j)==0)
+        return true;
+    if (h->expanding) {
+        // when we are expanding
+        // we could leave keys in their old but wrong buckets
+        uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
+        size_t i1 = _index_hash(h, hv);
+        size_t i2 = _alt_index(h, hv, i1);
+        if ((i != i1) && (i != i2)) {
+            TABLE_KEY(h, i, j)=0;
+            return true;
+        }
+    }
+    return false;
+}
+
+
+
+typedef struct  {
+    size_t buckets[NUM_CUCKOO_PATH];
+    size_t slots[NUM_CUCKOO_PATH];
+    KeyType keys[NUM_CUCKOO_PATH];
+}  __attribute__((__packed__))
+CuckooRecord;
+
+
+
+/**
+ * @brief Make bucket from[idx] slot[whichslot] available to insert a new item
+ *
+ * @param from:   the array of bucket index
+ * @param whichslot: the slot available
+ * @param  depth: the current cuckoo depth
+ *
+ * @return depth on success, -1 otherwise
+ */
+static int _cuckoopath_search(cuckoo_hashtable_t* h,
+                              CuckooRecord* cuckoo_path,
+                              size_t *cp_index,
+                              size_t *num_kicks) {
+
+    int depth = 0;
+    while ((*num_kicks < MAX_CUCKOO_COUNT) &&
+           (depth >= 0) &&
+           (depth < MAX_CUCKOO_COUNT - 1)) {
+
+        CuckooRecord *curr = cuckoo_path + depth;
+        CuckooRecord *next = cuckoo_path + depth + 1;
+
+        /*
+         * Check if any slot is already free
+         */
+        size_t idx;
+        for (idx = 0; idx < NUM_CUCKOO_PATH; idx ++) {
+            size_t i;
+            size_t j;
+            i = curr->buckets[idx];
+            for (j = 0; j < bucketsize; j ++) {
+                if (is_slot_empty(h, i, j)) {
+                    curr->slots[idx] = j;
+                    *cp_index   = idx;
+                    return depth;
+                }
+            }
+
+            /* pick the victim as the j-th item */
+            j = (cheap_rand() >> 20) % bucketsize;
+
+            curr->slots[idx] = j;
+            curr->keys[idx]  = TABLE_KEY(h, i, j);
+            uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
+            next->buckets[idx] = _alt_index(h, hv, i);
+        }
+
+        *num_kicks += NUM_CUCKOO_PATH;
+        depth ++;
+    }
+
+    DBG("%zu max cuckoo achieved, abort\n", *num_kicks);
+    return -1;
+}
+
+static int _cuckoopath_move(cuckoo_hashtable_t* h,
+                            CuckooRecord* cuckoo_path,
+                            size_t depth,
+                            size_t idx) {
+
+    while (depth > 0) {
+
+        /*
+         * Move the key/value in  buckets[i1] slot[j1] to buckets[i2] slot[j2]
+         * and make buckets[i1] slot[j1] available
+         *
+         */
+        CuckooRecord *from = cuckoo_path + depth - 1;
+        CuckooRecord *to   = cuckoo_path + depth;
+        size_t i1 = from->buckets[idx];
+        size_t j1 = from->slots[idx];
+        size_t i2 = to->buckets[idx];
+        size_t j2 = to->slots[idx];
+
+        /*
+         * We plan to kick out j1, but let's check if it is still there;
+         * there's a small chance we've gotten scooped by a later cuckoo.
+         * If that happened, just... try again.
+         */
+        if (!keycmp((char*) &TABLE_KEY(h, i1, j1), (char*) &(from->keys[idx]))) {
+            /* try again */
+            return depth;
+        }
+
+        //assert(is_slot_empty(h, i2, j2));
+
+        uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i1, j1));
+        size_t keylock   = _lock_index(hv);
+
+        incr_keyver(h, keylock);
+
+        TABLE_KEY(h, i2, j2) = TABLE_KEY(h, i1, j1);
+        TABLE_VAL(h, i2, j2) = TABLE_VAL(h, i1, j1);
+        TABLE_KEY(h, i1, j1) = 0;
+        TABLE_VAL(h, i1, j1) = 0;
+
+        incr_keyver(h, keylock);
+
+        depth --;
+    }
+
+    return depth;
+
+}
+
+static bool _run_cuckoo(cuckoo_hashtable_t* h,
+                        size_t i1,
+                        size_t i2,
+                        size_t* i) {
+
+    CuckooRecord* cuckoo_path;
+
+    cuckoo_path = malloc(MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
+    if (! cuckoo_path) {
+        fprintf(stderr, "Failed to init cuckoo path.\n");
+        return -1;
+    }
+    memset(cuckoo_path, 0, MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
+
+    size_t idx;
+    for (idx = 0; idx < NUM_CUCKOO_PATH; idx ++) {
+        if (idx < NUM_CUCKOO_PATH / 2)
+            cuckoo_path[0].buckets[idx] = i1;
+        else
+            cuckoo_path[0].buckets[idx] = i2;
+    }
+
+    size_t num_kicks = 0;
+    while (1) {
+        int depth;
+        depth = _cuckoopath_search(h, cuckoo_path, &idx, &num_kicks);
+        if (depth < 0) 
+            break;
+
+        int curr_depth = _cuckoopath_move(h, cuckoo_path, depth, idx);
+        if (curr_depth == 0) {
+            *i = cuckoo_path[0].buckets[idx];
+            free(cuckoo_path);
+            return true;
+        }
+    }
+    free(cuckoo_path);
+    return false;
+}
+
+
+/**
+ * @brief Try to read bucket i and check if the given key is there
+ *
+ * @param key The key to search
+ * @param val The address to copy value to
+ * @param i Index of bucket
+ *
+ * @return true if key is found, false otherwise
+ */
+static bool _try_read_from_bucket(cuckoo_hashtable_t* h,
+                                  const char *key,
+                                  char *val,
+                                  size_t i) {
+    size_t  j;
+    for (j = 0; j < bucketsize; j ++) {
+
+        if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
+            memcpy(val, (char*) &TABLE_VAL(h, i, j), sizeof(ValType));
+            return true;
+        }
+    }
+    return false;
+}
+
+/**
+ * @brief Try to add key/val to bucket i,
+ *
+ * @param key Pointer to the key to store
+ * @param val Pointer to the value to store
+ * @param i Bucket index
+ * @param keylock The index of key version counter
+ *
+ * @return true on success and false on failure
+ */
+static bool _try_add_to_bucket(cuckoo_hashtable_t* h,
+                               const char* key,
+                               const char* val,
+                               size_t i,
+                               size_t keylock) {
+    size_t j;
+    for (j = 0; j < bucketsize; j ++) {
+        if (is_slot_empty(h, i, j)) {
+
+            incr_keyver(h, keylock);
+
+            memcpy(&TABLE_KEY(h, i, j), key, sizeof(KeyType));
+            memcpy(&TABLE_VAL(h, i, j), val, sizeof(ValType));
+
+            h->hashitems ++;
+
+            incr_keyver(h, keylock);
+            return true;
+        }
+    }
+    return false;
+}
+
+
+
+
+/**
+ * @brief Try to delete key and its corresponding value from bucket i,
+ *
+ * @param key Pointer to the key to store
+ * @param i Bucket index
+ * @param keylock The index of key version counter
+
+ * @return true if key is found, false otherwise
+ */
+static bool _try_del_from_bucket(cuckoo_hashtable_t* h,
+                                 const char*key,
+                                 size_t i,
+                                 size_t keylock) {
+    size_t j;
+    for (j = 0; j < bucketsize; j ++) {
+
+        if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
+
+            incr_keyver(h, keylock);
+
+            TABLE_KEY(h, i, j) = 0;
+            TABLE_VAL(h, i, j) = 0;
+            /* buckets[i].keys[j] = 0; */
+            /* buckets[i].vals[j] = 0; */
+
+            h->hashitems --;
+
+            incr_keyver(h, keylock);
+            return true;
+        }
+    }
+    return false;
+}
+
+
+/**
+ * @brief internal of cuckoo_find
+ *
+ * @param key
+ * @param val
+ * @param i1
+ * @param i2
+ * @param keylock
+ *
+ * @return
+ */
+static cuckoo_status _cuckoo_find(cuckoo_hashtable_t* h,
+                                  const char *key,
+                                  char *val,
+                                  size_t i1,
+                                  size_t i2,
+                                  size_t keylock) {
+    bool result;
+
+    uint32_t vs, ve;
+TryRead:
+    vs = read_keyver(h, keylock);
+
+    result = _try_read_from_bucket(h, key, val, i1);
+    if (!result) {
+        result = _try_read_from_bucket(h, key, val, i2);
+    }
+
+    ve = read_keyver(h, keylock);
+
+    if (vs & 1 || vs != ve)
+        goto TryRead;
+
+    if (result)
+        return ok;
+    else
+        return failure_key_not_found;
+}
+
+static cuckoo_status _cuckoo_insert(cuckoo_hashtable_t* h,
+                                    const char* key,
+                                    const char* val,
+                                    size_t i1,
+                                    size_t i2,
+                                    size_t keylock) {
+
+    /*
+     * try to add new key to bucket i1 first, then try bucket i2
+     */
+    if (_try_add_to_bucket(h, key, val, i1, keylock))
+        return ok;
+
+    if (_try_add_to_bucket(h, key, val, i2, keylock))
+        return ok;
+
+
+    /*
+     * we are unlucky, so let's perform cuckoo hashing
+     */
+    size_t i = 0;
+            
+    if (_run_cuckoo(h, i1, i2, &i)) {
+        if (_try_add_to_bucket(h, key, val, i, keylock)) {
+            return ok;
+        }
+    }
+
+    DBG("hash table is full (hashpower = %zu, hash_items = %zu, load factor = %.2f), need to increase hashpower\n",
+        h->hashpower, h->hashitems, 1.0 * h->hashitems / bucketsize / hashsize(h->hashpower));
+
+
+    return failure_table_full;
+
+}
+
+static cuckoo_status _cuckoo_delete(cuckoo_hashtable_t* h,
+                                    const char* key,
+                                    size_t i1,
+                                    size_t i2,
+                                    size_t keylock) {
+    if (_try_del_from_bucket(h, key, i1, keylock))
+        return ok;
+
+    if (_try_del_from_bucket(h, key, i2, keylock))
+        return ok;
+
+    return failure_key_not_found;
+
+}
+
+static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
+    size_t i, j, ii;
+
+    for (ii = 0; ii < size; ++ii) {
+        i = h->cleaned_buckets;
+        uint32_t hv;
+        for (j = 0; j < bucketsize; j ++) {
+            if (TABLE_KEY(h, i, j) == 0) {
+                continue;
+            }
+            hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
+            size_t i1 = _index_hash(h, hv);
+            size_t i2 = _alt_index(h, hv, i1);
+            if ((i != i1) && (i != i2)) {
+                //DBG("delete key %u , i=%zu i1=%zu i2=%zu\n", TABLE_KEY(h, i, j), i, i1, i2);
+
+                TABLE_KEY(h, i, j) = 0;
+                TABLE_VAL(h, i, j) = 0;
+            }
+        }
+        h->cleaned_buckets ++;
+        if (h->cleaned_buckets == hashsize((h->hashpower))) {
+            h->expanding = false;
+            DBG("table clean done, cleaned_buckets = %zu\n", h->cleaned_buckets);
+            return;
+        }
+    }
+    //DBG("_cuckoo_clean: cleaned_buckets = %zu\n", h->cleaned_buckets);
+}
+
+
+/********************************************************************
+ *               Interface of cuckoo hash table
+ *********************************************************************/
+
+cuckoo_hashtable_t* cuckoo_init(const int hashtable_init) {
+    cuckoo_hashtable_t* h = (cuckoo_hashtable_t*) malloc(sizeof(cuckoo_hashtable_t));
+    if (!h)
+        goto Cleanup;
+
+    h->hashpower  = (hashtable_init > 0) ? hashtable_init : HASHPOWER_DEFAULT;
+    h->hashitems  = 0;
+    h->expanding  = false;
+    pthread_mutex_init(&h->lock, NULL);
+
+    h->buckets = malloc(hashsize(h->hashpower) * sizeof(Bucket));
+    if (! h->buckets) {
+        fprintf(stderr, "Failed to init hashtable.\n");
+        goto Cleanup;
+    }
+
+    h->keyver_array = malloc(keyver_count * sizeof(uint32_t));
+    if (! h->keyver_array) {
+        fprintf(stderr, "Failed to init key version array.\n");
+        goto Cleanup;
+    }
+
+
+    memset(h->buckets, 0, hashsize(h->hashpower) * sizeof(Bucket));
+    memset(h->keyver_array, 0, keyver_count * sizeof(uint32_t));
+
+    return h;
+
+Cleanup:
+    if (h) {
+        free(h->keyver_array);
+        free(h->buckets);
+    }
+    free(h);
+    return NULL;
+
+}
+
+cuckoo_status cuckoo_exit(cuckoo_hashtable_t* h) {
+    pthread_mutex_destroy(&h->lock);
+    free(h->buckets);
+    free(h->keyver_array);
+    free(h);
+    return ok;
+}
+
+cuckoo_status cuckoo_find(cuckoo_hashtable_t* h,
+                          const char *key,
+                          char *val) {
+
+    uint32_t hv    = _hashed_key(key);
+    size_t i1      = _index_hash(h, hv);
+    size_t i2      = _alt_index(h, hv, i1);
+    size_t keylock = _lock_index(hv);
+
+    cuckoo_status st = _cuckoo_find(h, key, val, i1, i2, keylock);
+
+    if (st == failure_key_not_found) {
+        DBG("miss for key %u i1=%zu i2=%zu hv=%u\n", *((KeyType*) key), i1, i2, hv);
+    }
+
+    return st;
+}
+
+cuckoo_status cuckoo_insert(cuckoo_hashtable_t* h,
+                            const char *key,
+                            const char* val) {
+    mutex_lock(&h->lock);
+
+    uint32_t hv = _hashed_key(key);
+    size_t i1   = _index_hash(h, hv);
+    size_t i2   = _alt_index(h, hv, i1);
+    size_t keylock = _lock_index(hv);
+
+    ValType oldval;
+    cuckoo_status st;
+
+    st = _cuckoo_find(h, key, (char*) &oldval, i1, i2, keylock);
+    if  (st == ok) {
+        mutex_unlock(&h->lock);
+        return failure_key_duplicated;
+    }
+
+    st =  _cuckoo_insert(h, key, val, i1, i2, keylock);
+
+    if (h->expanding) {
+        // still some work to do
+        _cuckoo_clean(h, DEFAULT_BULK_CLEAN);
+    }
+
+    mutex_unlock(&h->lock);
+
+    return st;
+}
+
+cuckoo_status cuckoo_delete(cuckoo_hashtable_t* h,
+                            const char *key) {
+
+    mutex_lock(&h->lock);
+
+    uint32_t hv = _hashed_key(key);
+    size_t i1   = _index_hash(h, hv);
+    size_t i2   = _alt_index(h, hv, i1);
+    size_t keylock = _lock_index(hv);
+
+    cuckoo_status st;
+
+    st = _cuckoo_delete(h, key, i1, i2, keylock);
+
+    mutex_unlock(&h->lock);
+
+    return st;
+}
+
+cuckoo_status cuckoo_expand(cuckoo_hashtable_t* h) {
+
+    mutex_lock(&h->lock);
+    if (h->expanding) {
+        mutex_unlock(&h->lock);
+        //DBG("expansion is on-going\n", NULL);
+        return failure_under_expansion;
+    }
+    
+    h->expanding = true;
+
+    Bucket* old_buckets = (Bucket*) h->buckets;
+    Bucket* new_buckets = (Bucket*) malloc(hashsize((h->hashpower + 1)) * sizeof(Bucket));
+    if (!new_buckets) {
+        h->expanding = false;
+        mutex_unlock(&h->lock);
+        return failure_space_not_enough;
+    }
+
+    memcpy(new_buckets, h->buckets, hashsize(h->hashpower) * sizeof(Bucket));
+    memcpy(new_buckets + hashsize(h->hashpower), h->buckets, hashsize(h->hashpower) * sizeof(Bucket));
+
+
+    h->buckets = new_buckets;
+    h->hashpower ++;
+    h->cleaned_buckets = 0;
+
+    //h->expanding = false;
+    //_cuckoo_clean(h, hashsize(h->hashpower));
+
+    mutex_unlock(&h->lock);
+
+    free(old_buckets);
+
+    return ok;
+}
+
+void cuckoo_report(cuckoo_hashtable_t* h) {
+
+    size_t sz;
+    sz = sizeof(Bucket) * hashsize(h->hashpower);
+    DBG("total number of items %zu\n", h->hashitems);
+    DBG("total size %zu Bytes, or %.2f MB\n", sz, (float) sz / (1 <<20));
+    DBG("load factor %.4f\n", 1.0 * h->hashitems / bucketsize / hashsize(h->hashpower));
+}
+
+float cuckoo_loadfactor(cuckoo_hashtable_t* h) {
+    return 1.0 * h->hashitems / bucketsize / hashsize(h->hashpower);
+}

commit 1abc36e0e2f4bed9516efe52af4993dad5f05929
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Fri Mar 8 15:18:56 2013 -0500

    use mersenne twister for workload generator

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
deleted file mode 100644
index 42f5550..0000000
--- a/lib/cuckoohash.c
+++ /dev/null
@@ -1,676 +0,0 @@
-/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
-/**
- * @file   cuckoohash.c
- * @author Bin Fan <binfan@cs.cmu.edu>
- * @date   Mon Feb 25 22:17:04 2013
- *
- * @brief  implementation of single-writer/multi-reader cuckoo hash
- *
- *
- */
-
-#include "cuckoohash.h"
-
-/*
- * default hash table size
- */
-#define HASHPOWER_DEFAULT 16
-
-/*
- * The maximum number of cuckoo operations per insert,
- */
-#define MAX_CUCKOO_COUNT 500
-
-/*
- * The number of cuckoo paths
- */
-#define NUM_CUCKOO_PATH 2
-
-#define  keyver_count ((uint32_t)1 << (13))
-#define  keyver_mask  (keyver_count - 1)
-
-
-/*
- * the structure of a bucket
- */
-#define bucketsize 4
-typedef struct {
-    KeyType keys[bucketsize];
-    ValType vals[bucketsize];
-}  __attribute__((__packed__))
-Bucket;
-
-
-/**
- *  @brief Atomic read the counter
- *
- */
-#define read_keyver(h, idx)                                      \
-    __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 0)
-
-/**
- * @brief Atomic increase the counter
- *
- */
-#define incr_keyver(h, idx)                                      \
-    __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 1)
-
-
-static inline  uint32_t _hashed_key(const char* key) {
-    return CityHash32(key, sizeof(KeyType));
-}
-
-#define hashsize(n) ((uint32_t) 1 << n)
-#define hashmask(n) (hashsize(n) - 1)
-
-
-
-/**
- * @brief Compute the index of the first bucket
- *
- * @param hv 32-bit hash value of the key
- *
- * @return The first bucket
- */
-static inline size_t _index_hash(cuckoo_hashtable_t* h,
-                                 const uint32_t hv) {
-//    return  (hv >> (32 - h->hashpower));
-    return  (hv & hashmask(h->hashpower));
-}
-
-
-/**
- * @brief Compute the index of the second bucket
- *
- * @param hv 32-bit hash value of the key
- * @param index The index of the first bucket
- *
- * @return  The second bucket
- */
-static inline size_t _alt_index(cuckoo_hashtable_t* h,
-                                const uint32_t hv,
-                                const size_t index) {
-    // 0x5bd1e995 is the hash constant from MurmurHash2
-    //uint32_t tag = hv & 0xFF;
-    uint32_t tag = hv >> 24;
-    return (index ^ (tag * 0x5bd1e995)) & hashmask(h->hashpower);
-    //return (hv ^ (tag * 0x5bd1e995)) & hashmask(h->hashpower);
-    //return ((hv >> 32) & hashmask(h->hashpower));
-}
-
-/**
- * @brief Compute the index of the corresponding counter in keyver_array
- *
- * @param hv 32-bit hash value of the key
- *
- * @return The index of the counter
- */
-static inline size_t _lock_index(const uint32_t hv) {
-    return hv & keyver_mask;
-}
-
-
-#define TABLE_KEY(h, i, j) ((Bucket*) h->buckets)[i].keys[j]
-#define TABLE_VAL(h, i, j) ((Bucket*) h->buckets)[i].vals[j]
-
-
-//#define IS_SLOT_EMPTY(h, i, j) (TABLE_KEY(h, i, j)==0)
-static inline bool is_slot_empty(cuckoo_hashtable_t* h,
-                                 size_t i,
-                                 size_t j) {
-    if (TABLE_KEY(h, i, j)==0)
-        return true;
-    if (h->expanding) {
-        // when we are expanding
-        // we could leave keys in their old but wrong buckets
-        uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
-        size_t i1 = _index_hash(h, hv);
-        size_t i2 = _alt_index(h, hv, i1);
-        if ((i != i1) && (i != i2)) {
-            TABLE_KEY(h, i, j)=0;
-            return true;
-        }
-    }
-    return false;
-}
-
-
-
-typedef struct  {
-    size_t buckets[NUM_CUCKOO_PATH];
-    size_t slots[NUM_CUCKOO_PATH];
-    KeyType keys[NUM_CUCKOO_PATH];
-}  __attribute__((__packed__))
-CuckooRecord;
-
-
-
-/**
- * @brief Make bucket from[idx] slot[whichslot] available to insert a new item
- *
- * @param from:   the array of bucket index
- * @param whichslot: the slot available
- * @param  depth: the current cuckoo depth
- *
- * @return depth on success, -1 otherwise
- */
-static int _cuckoopath_search(cuckoo_hashtable_t* h,
-                              CuckooRecord* cuckoo_path,
-                              size_t *cp_index,
-                              size_t *num_kicks) {
-
-    int depth = 0;
-    while ((*num_kicks < MAX_CUCKOO_COUNT) &&
-           (depth >= 0) &&
-           (depth < MAX_CUCKOO_COUNT - 1)) {
-
-        CuckooRecord *curr = cuckoo_path + depth;
-        CuckooRecord *next = cuckoo_path + depth + 1;
-
-        /*
-         * Check if any slot is already free
-         */
-        size_t idx;
-        for (idx = 0; idx < NUM_CUCKOO_PATH; idx ++) {
-            size_t i;
-            size_t j;
-            i = curr->buckets[idx];
-            for (j = 0; j < bucketsize; j ++) {
-                if (is_slot_empty(h, i, j)) {
-                    curr->slots[idx] = j;
-                    *cp_index   = idx;
-                    return depth;
-                }
-            }
-
-            /* pick the victim as the j-th item */
-            j = (cheap_rand() >> 20) % bucketsize;
-
-            curr->slots[idx] = j;
-            curr->keys[idx]  = TABLE_KEY(h, i, j);
-            uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
-            next->buckets[idx] = _alt_index(h, hv, i);
-        }
-
-        *num_kicks += NUM_CUCKOO_PATH;
-        depth ++;
-    }
-
-    DBG("%zu max cuckoo achieved, abort\n", *num_kicks);
-    return -1;
-}
-
-static int _cuckoopath_move(cuckoo_hashtable_t* h,
-                            CuckooRecord* cuckoo_path,
-                            size_t depth,
-                            size_t idx) {
-
-    while (depth > 0) {
-
-        /*
-         * Move the key/value in  buckets[i1] slot[j1] to buckets[i2] slot[j2]
-         * and make buckets[i1] slot[j1] available
-         *
-         */
-        CuckooRecord *from = cuckoo_path + depth - 1;
-        CuckooRecord *to   = cuckoo_path + depth;
-        size_t i1 = from->buckets[idx];
-        size_t j1 = from->slots[idx];
-        size_t i2 = to->buckets[idx];
-        size_t j2 = to->slots[idx];
-
-        /*
-         * We plan to kick out j1, but let's check if it is still there;
-         * there's a small chance we've gotten scooped by a later cuckoo.
-         * If that happened, just... try again.
-         */
-        if (!keycmp((char*) &TABLE_KEY(h, i1, j1), (char*) &(from->keys[idx]))) {
-            /* try again */
-            return depth;
-        }
-
-        //assert(is_slot_empty(h, i2, j2));
-
-        uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i1, j1));
-        size_t keylock   = _lock_index(hv);
-
-        incr_keyver(h, keylock);
-
-        TABLE_KEY(h, i2, j2) = TABLE_KEY(h, i1, j1);
-        TABLE_VAL(h, i2, j2) = TABLE_VAL(h, i1, j1);
-        TABLE_KEY(h, i1, j1) = 0;
-        TABLE_VAL(h, i1, j1) = 0;
-
-        incr_keyver(h, keylock);
-
-        depth --;
-    }
-
-    return depth;
-
-}
-
-static bool _run_cuckoo(cuckoo_hashtable_t* h,
-                        size_t i1,
-                        size_t i2,
-                        size_t* i) {
-
-    CuckooRecord* cuckoo_path;
-
-    cuckoo_path = malloc(MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
-    if (! cuckoo_path) {
-        fprintf(stderr, "Failed to init cuckoo path.\n");
-        return -1;
-    }
-    memset(cuckoo_path, 0, MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
-
-    size_t idx;
-    for (idx = 0; idx < NUM_CUCKOO_PATH; idx ++) {
-        if (idx < NUM_CUCKOO_PATH / 2)
-            cuckoo_path[0].buckets[idx] = i1;
-        else
-            cuckoo_path[0].buckets[idx] = i2;
-    }
-
-    size_t num_kicks = 0;
-    while (1) {
-        int depth;
-        depth = _cuckoopath_search(h, cuckoo_path, &idx, &num_kicks);
-        if (depth < 0) 
-            break;
-
-        int curr_depth = _cuckoopath_move(h, cuckoo_path, depth, idx);
-        if (curr_depth == 0) {
-            *i = cuckoo_path[0].buckets[idx];
-            free(cuckoo_path);
-            return true;
-        }
-    }
-    free(cuckoo_path);
-    return false;
-}
-
-
-/**
- * @brief Try to read bucket i and check if the given key is there
- *
- * @param key The key to search
- * @param val The address to copy value to
- * @param i Index of bucket
- *
- * @return true if key is found, false otherwise
- */
-static bool _try_read_from_bucket(cuckoo_hashtable_t* h,
-                                  const char *key,
-                                  char *val,
-                                  size_t i) {
-    size_t  j;
-    for (j = 0; j < bucketsize; j ++) {
-
-        if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
-            memcpy(val, (char*) &TABLE_VAL(h, i, j), sizeof(ValType));
-            return true;
-        }
-    }
-    return false;
-}
-
-/**
- * @brief Try to add key/val to bucket i,
- *
- * @param key Pointer to the key to store
- * @param val Pointer to the value to store
- * @param i Bucket index
- * @param keylock The index of key version counter
- *
- * @return true on success and false on failure
- */
-static bool _try_add_to_bucket(cuckoo_hashtable_t* h,
-                               const char* key,
-                               const char* val,
-                               size_t i,
-                               size_t keylock) {
-    size_t j;
-    for (j = 0; j < bucketsize; j ++) {
-        if (is_slot_empty(h, i, j)) {
-
-            incr_keyver(h, keylock);
-
-            memcpy(&TABLE_KEY(h, i, j), key, sizeof(KeyType));
-            memcpy(&TABLE_VAL(h, i, j), val, sizeof(ValType));
-
-            h->hashitems ++;
-
-            incr_keyver(h, keylock);
-            return true;
-        }
-    }
-    return false;
-}
-
-
-
-
-/**
- * @brief Try to delete key and its corresponding value from bucket i,
- *
- * @param key Pointer to the key to store
- * @param i Bucket index
- * @param keylock The index of key version counter
-
- * @return true if key is found, false otherwise
- */
-static bool _try_del_from_bucket(cuckoo_hashtable_t* h,
-                                 const char*key,
-                                 size_t i,
-                                 size_t keylock) {
-    size_t j;
-    for (j = 0; j < bucketsize; j ++) {
-
-        if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
-
-            incr_keyver(h, keylock);
-
-            TABLE_KEY(h, i, j) = 0;
-            TABLE_VAL(h, i, j) = 0;
-            /* buckets[i].keys[j] = 0; */
-            /* buckets[i].vals[j] = 0; */
-
-            h->hashitems --;
-
-            incr_keyver(h, keylock);
-            return true;
-        }
-    }
-    return false;
-}
-
-
-/**
- * @brief internal of cuckoo_find
- *
- * @param key
- * @param val
- * @param i1
- * @param i2
- * @param keylock
- *
- * @return
- */
-static cuckoo_status _cuckoo_find(cuckoo_hashtable_t* h,
-                                  const char *key,
-                                  char *val,
-                                  size_t i1,
-                                  size_t i2,
-                                  size_t keylock) {
-    bool result;
-
-    uint32_t vs, ve;
-TryRead:
-    vs = read_keyver(h, keylock);
-
-    result = _try_read_from_bucket(h, key, val, i1);
-    if (!result) {
-        result = _try_read_from_bucket(h, key, val, i2);
-    }
-
-    ve = read_keyver(h, keylock);
-
-    if (vs & 1 || vs != ve)
-        goto TryRead;
-
-    if (result)
-        return ok;
-    else
-        return failure_key_not_found;
-}
-
-static cuckoo_status _cuckoo_insert(cuckoo_hashtable_t* h,
-                                    const char* key,
-                                    const char* val,
-                                    size_t i1,
-                                    size_t i2,
-                                    size_t keylock) {
-
-    /*
-     * try to add new key to bucket i1 first, then try bucket i2
-     */
-    if (_try_add_to_bucket(h, key, val, i1, keylock))
-        return ok;
-
-    if (_try_add_to_bucket(h, key, val, i2, keylock))
-        return ok;
-
-
-    /*
-     * we are unlucky, so let's perform cuckoo hashing
-     */
-    size_t i = 0;
-            
-    if (_run_cuckoo(h, i1, i2, &i)) {
-        if (_try_add_to_bucket(h, key, val, i, keylock)) {
-            return ok;
-        }
-    }
-
-    DBG("hash table is full (hashpower = %zu, hash_items = %zu, load factor = %.2f), need to increase hashpower\n",
-        h->hashpower, h->hashitems, 1.0 * h->hashitems / bucketsize / hashsize(h->hashpower));
-
-
-    return failure_table_full;
-
-}
-
-static cuckoo_status _cuckoo_delete(cuckoo_hashtable_t* h,
-                                    const char* key,
-                                    size_t i1,
-                                    size_t i2,
-                                    size_t keylock) {
-    if (_try_del_from_bucket(h, key, i1, keylock))
-        return ok;
-
-    if (_try_del_from_bucket(h, key, i2, keylock))
-        return ok;
-
-    return failure_key_not_found;
-
-}
-
-static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
-    size_t i, j, ii;
-
-    for (ii = 0; ii < size; ++ii) {
-        i = h->cleaned_buckets;
-        uint32_t hv;
-        for (j = 0; j < bucketsize; j ++) {
-            if (TABLE_KEY(h, i, j) == 0) {
-                continue;
-            }
-            hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
-            size_t i1 = _index_hash(h, hv);
-            size_t i2 = _alt_index(h, hv, i1);
-            if ((i != i1) && (i != i2)) {
-                //DBG("delete key %u , i=%zu i1=%zu i2=%zu\n", TABLE_KEY(h, i, j), i, i1, i2);
-
-                TABLE_KEY(h, i, j) = 0;
-                TABLE_VAL(h, i, j) = 0;
-            }
-        }
-        h->cleaned_buckets ++;
-        if (h->cleaned_buckets == hashsize((h->hashpower))) {
-            h->expanding = false;
-            DBG("table clean done, cleaned_buckets = %zu\n", h->cleaned_buckets);
-            return;
-        }
-    }
-    //DBG("_cuckoo_clean: cleaned_buckets = %zu\n", h->cleaned_buckets);
-}
-
-
-/********************************************************************
- *               Interface of cuckoo hash table
- *********************************************************************/
-
-cuckoo_hashtable_t* cuckoo_init(const int hashtable_init) {
-    cuckoo_hashtable_t* h = (cuckoo_hashtable_t*) malloc(sizeof(cuckoo_hashtable_t));
-    if (!h)
-        goto Cleanup;
-
-    h->hashpower  = (hashtable_init > 0) ? hashtable_init : HASHPOWER_DEFAULT;
-    h->hashitems  = 0;
-    h->expanding  = false;
-    pthread_mutex_init(&h->lock, NULL);
-
-    h->buckets = malloc(hashsize(h->hashpower) * sizeof(Bucket));
-    if (! h->buckets) {
-        fprintf(stderr, "Failed to init hashtable.\n");
-        goto Cleanup;
-    }
-
-    h->keyver_array = malloc(keyver_count * sizeof(uint32_t));
-    if (! h->keyver_array) {
-        fprintf(stderr, "Failed to init key version array.\n");
-        goto Cleanup;
-    }
-
-
-    memset(h->buckets, 0, hashsize(h->hashpower) * sizeof(Bucket));
-    memset(h->keyver_array, 0, keyver_count * sizeof(uint32_t));
-
-    return h;
-
-Cleanup:
-    if (h) {
-        free(h->keyver_array);
-        free(h->buckets);
-    }
-    free(h);
-    return NULL;
-
-}
-
-cuckoo_status cuckoo_exit(cuckoo_hashtable_t* h) {
-    pthread_mutex_destroy(&h->lock);
-    free(h->buckets);
-    free(h->keyver_array);
-    free(h);
-    return ok;
-}
-
-cuckoo_status cuckoo_find(cuckoo_hashtable_t* h,
-                          const char *key,
-                          char *val) {
-
-    uint32_t hv    = _hashed_key(key);
-    size_t i1      = _index_hash(h, hv);
-    size_t i2      = _alt_index(h, hv, i1);
-    size_t keylock = _lock_index(hv);
-
-    cuckoo_status st = _cuckoo_find(h, key, val, i1, i2, keylock);
-
-    if (st == failure_key_not_found) {
-        DBG("miss for key %u i1=%zu i2=%zu hv=%u\n", *((KeyType*) key), i1, i2, hv);
-    }
-
-    return st;
-}
-
-cuckoo_status cuckoo_insert(cuckoo_hashtable_t* h,
-                            const char *key,
-                            const char* val) {
-    mutex_lock(&h->lock);
-
-    uint32_t hv = _hashed_key(key);
-    size_t i1   = _index_hash(h, hv);
-    size_t i2   = _alt_index(h, hv, i1);
-    size_t keylock = _lock_index(hv);
-
-    ValType oldval;
-    cuckoo_status st;
-
-    st = _cuckoo_find(h, key, (char*) &oldval, i1, i2, keylock);
-    if  (st == ok) {
-        mutex_unlock(&h->lock);
-        return failure_key_duplicated;
-    }
-
-    st =  _cuckoo_insert(h, key, val, i1, i2, keylock);
-
-    if (h->expanding) {
-        // still some work to do
-        _cuckoo_clean(h, DEFAULT_BULK_CLEAN);
-    }
-
-    mutex_unlock(&h->lock);
-
-    return st;
-}
-
-cuckoo_status cuckoo_delete(cuckoo_hashtable_t* h,
-                            const char *key) {
-
-    mutex_lock(&h->lock);
-
-    uint32_t hv = _hashed_key(key);
-    size_t i1   = _index_hash(h, hv);
-    size_t i2   = _alt_index(h, hv, i1);
-    size_t keylock = _lock_index(hv);
-
-    cuckoo_status st;
-
-    st = _cuckoo_delete(h, key, i1, i2, keylock);
-
-    mutex_unlock(&h->lock);
-
-    return st;
-}
-
-cuckoo_status cuckoo_expand(cuckoo_hashtable_t* h) {
-
-    mutex_lock(&h->lock);
-    if (h->expanding) {
-        mutex_unlock(&h->lock);
-        //DBG("expansion is on-going\n", NULL);
-        return failure_under_expansion;
-    }
-    
-    h->expanding = true;
-
-    Bucket* old_buckets = (Bucket*) h->buckets;
-    Bucket* new_buckets = (Bucket*) malloc(hashsize((h->hashpower + 1)) * sizeof(Bucket));
-    if (!new_buckets) {
-        h->expanding = false;
-        mutex_unlock(&h->lock);
-        return failure_space_not_enough;
-    }
-
-    memcpy(new_buckets, h->buckets, hashsize(h->hashpower) * sizeof(Bucket));
-    memcpy(new_buckets + hashsize(h->hashpower), h->buckets, hashsize(h->hashpower) * sizeof(Bucket));
-
-
-    h->buckets = new_buckets;
-    h->hashpower ++;
-    h->cleaned_buckets = 0;
-
-    //h->expanding = false;
-    //_cuckoo_clean(h, hashsize(h->hashpower));
-
-    mutex_unlock(&h->lock);
-
-    free(old_buckets);
-
-    return ok;
-}
-
-void cuckoo_report(cuckoo_hashtable_t* h) {
-
-    size_t sz;
-    sz = sizeof(Bucket) * hashsize(h->hashpower);
-    DBG("total number of items %zu\n", h->hashitems);
-    DBG("total size %zu Bytes, or %.2f MB\n", sz, (float) sz / (1 <<20));
-    DBG("load factor %.4f\n", 1.0 * h->hashitems / bucketsize / hashsize(h->hashpower));
-}
-
-float cuckoo_loadfactor(cuckoo_hashtable_t* h) {
-    return 1.0 * h->hashitems / bucketsize / hashsize(h->hashpower);
-}

commit 77fae736342e4fa4874ad4237b0e87e08bbca4cf
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Fri Mar 8 12:42:29 2013 -0500

    use cheap_rand to replace rand()

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index 5c788eb..42f5550 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -184,7 +184,8 @@ static int _cuckoopath_search(cuckoo_hashtable_t* h,
             }
 
             /* pick the victim as the j-th item */
-            j = rand() % bucketsize;
+            j = (cheap_rand() >> 20) % bucketsize;
+
             curr->slots[idx] = j;
             curr->keys[idx]  = TABLE_KEY(h, i, j);
             uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
@@ -228,7 +229,7 @@ static int _cuckoopath_move(cuckoo_hashtable_t* h,
             return depth;
         }
 
-        assert(is_slot_empty(h, i2, j2));
+        //assert(is_slot_empty(h, i2, j2));
 
         uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i1, j1));
         size_t keylock   = _lock_index(hv);
@@ -307,7 +308,6 @@ static bool _try_read_from_bucket(cuckoo_hashtable_t* h,
     for (j = 0; j < bucketsize; j ++) {
 
         if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
-
             memcpy(val, (char*) &TABLE_VAL(h, i, j), sizeof(ValType));
             return true;
         }
@@ -445,7 +445,7 @@ static cuckoo_status _cuckoo_insert(cuckoo_hashtable_t* h,
     /*
      * we are unlucky, so let's perform cuckoo hashing
      */
-    size_t i;
+    size_t i = 0;
             
     if (_run_cuckoo(h, i1, i2, &i)) {
         if (_try_add_to_bucket(h, key, val, i, keylock)) {

commit 28f9a05db5e1b853031f205d3d3abfb4a7d1ada2
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Fri Mar 8 00:23:34 2013 -0500

    make cuckoo_path per insert, rather than per hash table. So I could have multiple writers later

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index ca4f3dd..5c788eb 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -127,7 +127,7 @@ static inline bool is_slot_empty(cuckoo_hashtable_t* h,
         size_t i1 = _index_hash(h, hv);
         size_t i2 = _alt_index(h, hv, i1);
         if ((i != i1) && (i != i2)) {
-            TABLE_KEY(h, i, j)==0;
+            TABLE_KEY(h, i, j)=0;
             return true;
         }
     }
@@ -155,16 +155,17 @@ CuckooRecord;
  * @return depth on success, -1 otherwise
  */
 static int _cuckoopath_search(cuckoo_hashtable_t* h,
-                              size_t depth_start,
-                              size_t *cp_index) {
+                              CuckooRecord* cuckoo_path,
+                              size_t *cp_index,
+                              size_t *num_kicks) {
 
-    int depth = depth_start;
-    while ((h->kick_count < MAX_CUCKOO_COUNT) &&
+    int depth = 0;
+    while ((*num_kicks < MAX_CUCKOO_COUNT) &&
            (depth >= 0) &&
            (depth < MAX_CUCKOO_COUNT - 1)) {
 
-        CuckooRecord *curr = ((CuckooRecord*) h->cuckoo_path) + depth;
-        CuckooRecord *next = ((CuckooRecord*) h->cuckoo_path) + depth + 1;
+        CuckooRecord *curr = cuckoo_path + depth;
+        CuckooRecord *next = cuckoo_path + depth + 1;
 
         /*
          * Check if any slot is already free
@@ -190,19 +191,19 @@ static int _cuckoopath_search(cuckoo_hashtable_t* h,
             next->buckets[idx] = _alt_index(h, hv, i);
         }
 
-        h->kick_count += NUM_CUCKOO_PATH;
+        *num_kicks += NUM_CUCKOO_PATH;
         depth ++;
     }
 
-    DBG("%zu max cuckoo achieved, abort\n", h->kick_count);
+    DBG("%zu max cuckoo achieved, abort\n", *num_kicks);
     return -1;
 }
 
 static int _cuckoopath_move(cuckoo_hashtable_t* h,
-                            size_t depth_start,
+                            CuckooRecord* cuckoo_path,
+                            size_t depth,
                             size_t idx) {
 
-    int depth = depth_start;
     while (depth > 0) {
 
         /*
@@ -210,8 +211,8 @@ static int _cuckoopath_move(cuckoo_hashtable_t* h,
          * and make buckets[i1] slot[j1] available
          *
          */
-        CuckooRecord *from = ((CuckooRecord*) h->cuckoo_path) + depth - 1;
-        CuckooRecord *to   = ((CuckooRecord*) h->cuckoo_path) + depth;
+        CuckooRecord *from = cuckoo_path + depth - 1;
+        CuckooRecord *to   = cuckoo_path + depth;
         size_t i1 = from->buckets[idx];
         size_t j1 = from->slots[idx];
         size_t i2 = to->buckets[idx];
@@ -248,35 +249,44 @@ static int _cuckoopath_move(cuckoo_hashtable_t* h,
 
 }
 
-static int _run_cuckoo(cuckoo_hashtable_t* h,
-                       size_t i1,
-                       size_t i2) {
-    int cur;
+static bool _run_cuckoo(cuckoo_hashtable_t* h,
+                        size_t i1,
+                        size_t i2,
+                        size_t* i) {
+
+    CuckooRecord* cuckoo_path;
+
+    cuckoo_path = malloc(MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
+    if (! cuckoo_path) {
+        fprintf(stderr, "Failed to init cuckoo path.\n");
+        return -1;
+    }
+    memset(cuckoo_path, 0, MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
 
     size_t idx;
-    size_t depth = 0;
     for (idx = 0; idx < NUM_CUCKOO_PATH; idx ++) {
-        if (idx< NUM_CUCKOO_PATH/2)
-            ((CuckooRecord*) h->cuckoo_path)[depth].buckets[idx] = i1;
+        if (idx < NUM_CUCKOO_PATH / 2)
+            cuckoo_path[0].buckets[idx] = i1;
         else
-            ((CuckooRecord*) h->cuckoo_path)[depth].buckets[idx] = i2;
+            cuckoo_path[0].buckets[idx] = i2;
     }
 
-    h->kick_count = 0;
+    size_t num_kicks = 0;
     while (1) {
-
-        cur = _cuckoopath_search(h, depth, &idx);
-        if (cur < 0)
-            return -1;
-
-        cur = _cuckoopath_move(h, cur, idx);
-        if (cur == 0)
-            return idx;
-
-        depth = cur - 1;
+        int depth;
+        depth = _cuckoopath_search(h, cuckoo_path, &idx, &num_kicks);
+        if (depth < 0) 
+            break;
+
+        int curr_depth = _cuckoopath_move(h, cuckoo_path, depth, idx);
+        if (curr_depth == 0) {
+            *i = cuckoo_path[0].buckets[idx];
+            free(cuckoo_path);
+            return true;
+        }
     }
-
-    return -1;
+    free(cuckoo_path);
+    return false;
 }
 
 
@@ -435,11 +445,9 @@ static cuckoo_status _cuckoo_insert(cuckoo_hashtable_t* h,
     /*
      * we are unlucky, so let's perform cuckoo hashing
      */
-    int idx = _run_cuckoo(h, i1, i2);
-    if (idx >= 0) {
-        size_t i;
-        i = ((CuckooRecord*) h->cuckoo_path)[0].buckets[idx];
-        //j = cuckoo_path[0].slots[idx];
+    size_t i;
+            
+    if (_run_cuckoo(h, i1, i2, &i)) {
         if (_try_add_to_bucket(h, key, val, i, keylock)) {
             return ok;
         }
@@ -510,7 +518,6 @@ cuckoo_hashtable_t* cuckoo_init(const int hashtable_init) {
 
     h->hashpower  = (hashtable_init > 0) ? hashtable_init : HASHPOWER_DEFAULT;
     h->hashitems  = 0;
-    h->kick_count = 0;
     h->expanding  = false;
     pthread_mutex_init(&h->lock, NULL);
 
@@ -526,21 +533,14 @@ cuckoo_hashtable_t* cuckoo_init(const int hashtable_init) {
         goto Cleanup;
     }
 
-    h->cuckoo_path = malloc(MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
-    if (! h->cuckoo_path) {
-        fprintf(stderr, "Failed to init cuckoo path.\n");
-        goto Cleanup;
-    }
 
     memset(h->buckets, 0, hashsize(h->hashpower) * sizeof(Bucket));
     memset(h->keyver_array, 0, keyver_count * sizeof(uint32_t));
-    memset(h->cuckoo_path, 0, MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
 
     return h;
 
 Cleanup:
     if (h) {
-        free(h->cuckoo_path);
         free(h->keyver_array);
         free(h->buckets);
     }

commit ede721a2fbc09b77621364ce6d457630db704157
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Thu Mar 7 23:27:14 2013 -0500

    checkpoint

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index 2322eea..ca4f3dd 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -55,6 +55,7 @@ Bucket;
 #define incr_keyver(h, idx)                                      \
     __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 1)
 
+
 static inline  uint32_t _hashed_key(const char* key) {
     return CityHash32(key, sizeof(KeyType));
 }
@@ -126,6 +127,7 @@ static inline bool is_slot_empty(cuckoo_hashtable_t* h,
         size_t i1 = _index_hash(h, hv);
         size_t i2 = _alt_index(h, hv, i1);
         if ((i != i1) && (i != i2)) {
+            TABLE_KEY(h, i, j)==0;
             return true;
         }
     }
@@ -567,7 +569,7 @@ cuckoo_status cuckoo_find(cuckoo_hashtable_t* h,
     cuckoo_status st = _cuckoo_find(h, key, val, i1, i2, keylock);
 
     if (st == failure_key_not_found) {
-        DBG("miss for key %u i1=%zu i2=%zu hv=%zu\n", *((KeyType*) key), i1, i2, hv);
+        DBG("miss for key %u i1=%zu i2=%zu hv=%u\n", *((KeyType*) key), i1, i2, hv);
     }
 
     return st;
@@ -650,8 +652,8 @@ cuckoo_status cuckoo_expand(cuckoo_hashtable_t* h) {
     h->hashpower ++;
     h->cleaned_buckets = 0;
 
-    h->expanding = false;
-    _cuckoo_clean(h, hashsize(h->hashpower));
+    //h->expanding = false;
+    //_cuckoo_clean(h, hashsize(h->hashpower));
 
     mutex_unlock(&h->lock);
 

commit c02a9cd8df2d41eb2327a191963b94c33e9521f3
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Thu Mar 7 21:34:22 2013 -0500

    add a function to return load factor

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index 028d2cc..2322eea 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -650,6 +650,9 @@ cuckoo_status cuckoo_expand(cuckoo_hashtable_t* h) {
     h->hashpower ++;
     h->cleaned_buckets = 0;
 
+    h->expanding = false;
+    _cuckoo_clean(h, hashsize(h->hashpower));
+
     mutex_unlock(&h->lock);
 
     free(old_buckets);
@@ -665,3 +668,7 @@ void cuckoo_report(cuckoo_hashtable_t* h) {
     DBG("total size %zu Bytes, or %.2f MB\n", sz, (float) sz / (1 <<20));
     DBG("load factor %.4f\n", 1.0 * h->hashitems / bucketsize / hashsize(h->hashpower));
 }
+
+float cuckoo_loadfactor(cuckoo_hashtable_t* h) {
+    return 1.0 * h->hashitems / bucketsize / hashsize(h->hashpower);
+}

commit ea1712c8969c8623de88c94d55cb08b016c21f6c
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Thu Mar 7 18:06:01 2013 -0500

    fix a concurrent bug where some keys are missing after table expansion.

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
index 7bf2707..028d2cc 100644
--- a/lib/cuckoohash.c
+++ b/lib/cuckoohash.c
@@ -469,7 +469,7 @@ static cuckoo_status _cuckoo_delete(cuckoo_hashtable_t* h,
 static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
     size_t i, j, ii;
 
-    for (ii = 0; ii < size && h->expanding; ++ii) {
+    for (ii = 0; ii < size; ++ii) {
         i = h->cleaned_buckets;
         uint32_t hv;
         for (j = 0; j < bucketsize; j ++) {
@@ -481,6 +481,7 @@ static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
             size_t i2 = _alt_index(h, hv, i1);
             if ((i != i1) && (i != i2)) {
                 //DBG("delete key %u , i=%zu i1=%zu i2=%zu\n", TABLE_KEY(h, i, j), i, i1, i2);
+
                 TABLE_KEY(h, i, j) = 0;
                 TABLE_VAL(h, i, j) = 0;
             }
@@ -492,7 +493,7 @@ static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
             return;
         }
     }
-    DBG("_cuckoo_clean: cleaned_buckets = %zu\n", h->cleaned_buckets);
+    //DBG("_cuckoo_clean: cleaned_buckets = %zu\n", h->cleaned_buckets);
 }
 
 
@@ -575,6 +576,7 @@ cuckoo_status cuckoo_find(cuckoo_hashtable_t* h,
 cuckoo_status cuckoo_insert(cuckoo_hashtable_t* h,
                             const char *key,
                             const char* val) {
+    mutex_lock(&h->lock);
 
     uint32_t hv = _hashed_key(key);
     size_t i1   = _index_hash(h, hv);
@@ -584,8 +586,6 @@ cuckoo_status cuckoo_insert(cuckoo_hashtable_t* h,
     ValType oldval;
     cuckoo_status st;
 
-    mutex_lock(&h->lock);
-
     st = _cuckoo_find(h, key, (char*) &oldval, i1, i2, keylock);
     if  (st == ok) {
         mutex_unlock(&h->lock);
@@ -607,6 +607,8 @@ cuckoo_status cuckoo_insert(cuckoo_hashtable_t* h,
 cuckoo_status cuckoo_delete(cuckoo_hashtable_t* h,
                             const char *key) {
 
+    mutex_lock(&h->lock);
+
     uint32_t hv = _hashed_key(key);
     size_t i1   = _index_hash(h, hv);
     size_t i2   = _alt_index(h, hv, i1);
@@ -614,8 +616,6 @@ cuckoo_status cuckoo_delete(cuckoo_hashtable_t* h,
 
     cuckoo_status st;
 
-    mutex_lock(&h->lock);
-
     st = _cuckoo_delete(h, key, i1, i2, keylock);
 
     mutex_unlock(&h->lock);
@@ -650,10 +650,6 @@ cuckoo_status cuckoo_expand(cuckoo_hashtable_t* h) {
     h->hashpower ++;
     h->cleaned_buckets = 0;
 
-    // for debug
-    _cuckoo_clean(h, hashsize(h->hashpower));
-    h->expanding = false;
-
     mutex_unlock(&h->lock);
 
     free(old_buckets);

commit a68df7ffb20143d8534b28dad70c81179f1d42d9
Author: Bin Fan <binfan@cs.cmu.edu>
Date:   Thu Mar 7 15:40:41 2013 -0500

    initial import from github

diff --git a/lib/cuckoohash.c b/lib/cuckoohash.c
new file mode 100644
index 0000000..7bf2707
--- /dev/null
+++ b/lib/cuckoohash.c
@@ -0,0 +1,671 @@
+/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
+/**
+ * @file   cuckoohash.c
+ * @author Bin Fan <binfan@cs.cmu.edu>
+ * @date   Mon Feb 25 22:17:04 2013
+ *
+ * @brief  implementation of single-writer/multi-reader cuckoo hash
+ *
+ *
+ */
+
+#include "cuckoohash.h"
+
+/*
+ * default hash table size
+ */
+#define HASHPOWER_DEFAULT 16
+
+/*
+ * The maximum number of cuckoo operations per insert,
+ */
+#define MAX_CUCKOO_COUNT 500
+
+/*
+ * The number of cuckoo paths
+ */
+#define NUM_CUCKOO_PATH 2
+
+#define  keyver_count ((uint32_t)1 << (13))
+#define  keyver_mask  (keyver_count - 1)
+
+
+/*
+ * the structure of a bucket
+ */
+#define bucketsize 4
+typedef struct {
+    KeyType keys[bucketsize];
+    ValType vals[bucketsize];
+}  __attribute__((__packed__))
+Bucket;
+
+
+/**
+ *  @brief Atomic read the counter
+ *
+ */
+#define read_keyver(h, idx)                                      \
+    __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 0)
+
+/**
+ * @brief Atomic increase the counter
+ *
+ */
+#define incr_keyver(h, idx)                                      \
+    __sync_fetch_and_add(&((uint32_t*) h->keyver_array)[idx & keyver_mask], 1)
+
+static inline  uint32_t _hashed_key(const char* key) {
+    return CityHash32(key, sizeof(KeyType));
+}
+
+#define hashsize(n) ((uint32_t) 1 << n)
+#define hashmask(n) (hashsize(n) - 1)
+
+
+
+/**
+ * @brief Compute the index of the first bucket
+ *
+ * @param hv 32-bit hash value of the key
+ *
+ * @return The first bucket
+ */
+static inline size_t _index_hash(cuckoo_hashtable_t* h,
+                                 const uint32_t hv) {
+//    return  (hv >> (32 - h->hashpower));
+    return  (hv & hashmask(h->hashpower));
+}
+
+
+/**
+ * @brief Compute the index of the second bucket
+ *
+ * @param hv 32-bit hash value of the key
+ * @param index The index of the first bucket
+ *
+ * @return  The second bucket
+ */
+static inline size_t _alt_index(cuckoo_hashtable_t* h,
+                                const uint32_t hv,
+                                const size_t index) {
+    // 0x5bd1e995 is the hash constant from MurmurHash2
+    //uint32_t tag = hv & 0xFF;
+    uint32_t tag = hv >> 24;
+    return (index ^ (tag * 0x5bd1e995)) & hashmask(h->hashpower);
+    //return (hv ^ (tag * 0x5bd1e995)) & hashmask(h->hashpower);
+    //return ((hv >> 32) & hashmask(h->hashpower));
+}
+
+/**
+ * @brief Compute the index of the corresponding counter in keyver_array
+ *
+ * @param hv 32-bit hash value of the key
+ *
+ * @return The index of the counter
+ */
+static inline size_t _lock_index(const uint32_t hv) {
+    return hv & keyver_mask;
+}
+
+
+#define TABLE_KEY(h, i, j) ((Bucket*) h->buckets)[i].keys[j]
+#define TABLE_VAL(h, i, j) ((Bucket*) h->buckets)[i].vals[j]
+
+
+//#define IS_SLOT_EMPTY(h, i, j) (TABLE_KEY(h, i, j)==0)
+static inline bool is_slot_empty(cuckoo_hashtable_t* h,
+                                 size_t i,
+                                 size_t j) {
+    if (TABLE_KEY(h, i, j)==0)
+        return true;
+    if (h->expanding) {
+        // when we are expanding
+        // we could leave keys in their old but wrong buckets
+        uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
+        size_t i1 = _index_hash(h, hv);
+        size_t i2 = _alt_index(h, hv, i1);
+        if ((i != i1) && (i != i2)) {
+            return true;
+        }
+    }
+    return false;
+}
+
+
+
+typedef struct  {
+    size_t buckets[NUM_CUCKOO_PATH];
+    size_t slots[NUM_CUCKOO_PATH];
+    KeyType keys[NUM_CUCKOO_PATH];
+}  __attribute__((__packed__))
+CuckooRecord;
+
+
+
+/**
+ * @brief Make bucket from[idx] slot[whichslot] available to insert a new item
+ *
+ * @param from:   the array of bucket index
+ * @param whichslot: the slot available
+ * @param  depth: the current cuckoo depth
+ *
+ * @return depth on success, -1 otherwise
+ */
+static int _cuckoopath_search(cuckoo_hashtable_t* h,
+                              size_t depth_start,
+                              size_t *cp_index) {
+
+    int depth = depth_start;
+    while ((h->kick_count < MAX_CUCKOO_COUNT) &&
+           (depth >= 0) &&
+           (depth < MAX_CUCKOO_COUNT - 1)) {
+
+        CuckooRecord *curr = ((CuckooRecord*) h->cuckoo_path) + depth;
+        CuckooRecord *next = ((CuckooRecord*) h->cuckoo_path) + depth + 1;
+
+        /*
+         * Check if any slot is already free
+         */
+        size_t idx;
+        for (idx = 0; idx < NUM_CUCKOO_PATH; idx ++) {
+            size_t i;
+            size_t j;
+            i = curr->buckets[idx];
+            for (j = 0; j < bucketsize; j ++) {
+                if (is_slot_empty(h, i, j)) {
+                    curr->slots[idx] = j;
+                    *cp_index   = idx;
+                    return depth;
+                }
+            }
+
+            /* pick the victim as the j-th item */
+            j = rand() % bucketsize;
+            curr->slots[idx] = j;
+            curr->keys[idx]  = TABLE_KEY(h, i, j);
+            uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
+            next->buckets[idx] = _alt_index(h, hv, i);
+        }
+
+        h->kick_count += NUM_CUCKOO_PATH;
+        depth ++;
+    }
+
+    DBG("%zu max cuckoo achieved, abort\n", h->kick_count);
+    return -1;
+}
+
+static int _cuckoopath_move(cuckoo_hashtable_t* h,
+                            size_t depth_start,
+                            size_t idx) {
+
+    int depth = depth_start;
+    while (depth > 0) {
+
+        /*
+         * Move the key/value in  buckets[i1] slot[j1] to buckets[i2] slot[j2]
+         * and make buckets[i1] slot[j1] available
+         *
+         */
+        CuckooRecord *from = ((CuckooRecord*) h->cuckoo_path) + depth - 1;
+        CuckooRecord *to   = ((CuckooRecord*) h->cuckoo_path) + depth;
+        size_t i1 = from->buckets[idx];
+        size_t j1 = from->slots[idx];
+        size_t i2 = to->buckets[idx];
+        size_t j2 = to->slots[idx];
+
+        /*
+         * We plan to kick out j1, but let's check if it is still there;
+         * there's a small chance we've gotten scooped by a later cuckoo.
+         * If that happened, just... try again.
+         */
+        if (!keycmp((char*) &TABLE_KEY(h, i1, j1), (char*) &(from->keys[idx]))) {
+            /* try again */
+            return depth;
+        }
+
+        assert(is_slot_empty(h, i2, j2));
+
+        uint32_t hv = _hashed_key((char*) &TABLE_KEY(h, i1, j1));
+        size_t keylock   = _lock_index(hv);
+
+        incr_keyver(h, keylock);
+
+        TABLE_KEY(h, i2, j2) = TABLE_KEY(h, i1, j1);
+        TABLE_VAL(h, i2, j2) = TABLE_VAL(h, i1, j1);
+        TABLE_KEY(h, i1, j1) = 0;
+        TABLE_VAL(h, i1, j1) = 0;
+
+        incr_keyver(h, keylock);
+
+        depth --;
+    }
+
+    return depth;
+
+}
+
+static int _run_cuckoo(cuckoo_hashtable_t* h,
+                       size_t i1,
+                       size_t i2) {
+    int cur;
+
+    size_t idx;
+    size_t depth = 0;
+    for (idx = 0; idx < NUM_CUCKOO_PATH; idx ++) {
+        if (idx< NUM_CUCKOO_PATH/2)
+            ((CuckooRecord*) h->cuckoo_path)[depth].buckets[idx] = i1;
+        else
+            ((CuckooRecord*) h->cuckoo_path)[depth].buckets[idx] = i2;
+    }
+
+    h->kick_count = 0;
+    while (1) {
+
+        cur = _cuckoopath_search(h, depth, &idx);
+        if (cur < 0)
+            return -1;
+
+        cur = _cuckoopath_move(h, cur, idx);
+        if (cur == 0)
+            return idx;
+
+        depth = cur - 1;
+    }
+
+    return -1;
+}
+
+
+/**
+ * @brief Try to read bucket i and check if the given key is there
+ *
+ * @param key The key to search
+ * @param val The address to copy value to
+ * @param i Index of bucket
+ *
+ * @return true if key is found, false otherwise
+ */
+static bool _try_read_from_bucket(cuckoo_hashtable_t* h,
+                                  const char *key,
+                                  char *val,
+                                  size_t i) {
+    size_t  j;
+    for (j = 0; j < bucketsize; j ++) {
+
+        if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
+
+            memcpy(val, (char*) &TABLE_VAL(h, i, j), sizeof(ValType));
+            return true;
+        }
+    }
+    return false;
+}
+
+/**
+ * @brief Try to add key/val to bucket i,
+ *
+ * @param key Pointer to the key to store
+ * @param val Pointer to the value to store
+ * @param i Bucket index
+ * @param keylock The index of key version counter
+ *
+ * @return true on success and false on failure
+ */
+static bool _try_add_to_bucket(cuckoo_hashtable_t* h,
+                               const char* key,
+                               const char* val,
+                               size_t i,
+                               size_t keylock) {
+    size_t j;
+    for (j = 0; j < bucketsize; j ++) {
+        if (is_slot_empty(h, i, j)) {
+
+            incr_keyver(h, keylock);
+
+            memcpy(&TABLE_KEY(h, i, j), key, sizeof(KeyType));
+            memcpy(&TABLE_VAL(h, i, j), val, sizeof(ValType));
+
+            h->hashitems ++;
+
+            incr_keyver(h, keylock);
+            return true;
+        }
+    }
+    return false;
+}
+
+
+
+
+/**
+ * @brief Try to delete key and its corresponding value from bucket i,
+ *
+ * @param key Pointer to the key to store
+ * @param i Bucket index
+ * @param keylock The index of key version counter
+
+ * @return true if key is found, false otherwise
+ */
+static bool _try_del_from_bucket(cuckoo_hashtable_t* h,
+                                 const char*key,
+                                 size_t i,
+                                 size_t keylock) {
+    size_t j;
+    for (j = 0; j < bucketsize; j ++) {
+
+        if (keycmp((char*) &TABLE_KEY(h, i, j), key)) {
+
+            incr_keyver(h, keylock);
+
+            TABLE_KEY(h, i, j) = 0;
+            TABLE_VAL(h, i, j) = 0;
+            /* buckets[i].keys[j] = 0; */
+            /* buckets[i].vals[j] = 0; */
+
+            h->hashitems --;
+
+            incr_keyver(h, keylock);
+            return true;
+        }
+    }
+    return false;
+}
+
+
+/**
+ * @brief internal of cuckoo_find
+ *
+ * @param key
+ * @param val
+ * @param i1
+ * @param i2
+ * @param keylock
+ *
+ * @return
+ */
+static cuckoo_status _cuckoo_find(cuckoo_hashtable_t* h,
+                                  const char *key,
+                                  char *val,
+                                  size_t i1,
+                                  size_t i2,
+                                  size_t keylock) {
+    bool result;
+
+    uint32_t vs, ve;
+TryRead:
+    vs = read_keyver(h, keylock);
+
+    result = _try_read_from_bucket(h, key, val, i1);
+    if (!result) {
+        result = _try_read_from_bucket(h, key, val, i2);
+    }
+
+    ve = read_keyver(h, keylock);
+
+    if (vs & 1 || vs != ve)
+        goto TryRead;
+
+    if (result)
+        return ok;
+    else
+        return failure_key_not_found;
+}
+
+static cuckoo_status _cuckoo_insert(cuckoo_hashtable_t* h,
+                                    const char* key,
+                                    const char* val,
+                                    size_t i1,
+                                    size_t i2,
+                                    size_t keylock) {
+
+    /*
+     * try to add new key to bucket i1 first, then try bucket i2
+     */
+    if (_try_add_to_bucket(h, key, val, i1, keylock))
+        return ok;
+
+    if (_try_add_to_bucket(h, key, val, i2, keylock))
+        return ok;
+
+
+    /*
+     * we are unlucky, so let's perform cuckoo hashing
+     */
+    int idx = _run_cuckoo(h, i1, i2);
+    if (idx >= 0) {
+        size_t i;
+        i = ((CuckooRecord*) h->cuckoo_path)[0].buckets[idx];
+        //j = cuckoo_path[0].slots[idx];
+        if (_try_add_to_bucket(h, key, val, i, keylock)) {
+            return ok;
+        }
+    }
+
+    DBG("hash table is full (hashpower = %zu, hash_items = %zu, load factor = %.2f), need to increase hashpower\n",
+        h->hashpower, h->hashitems, 1.0 * h->hashitems / bucketsize / hashsize(h->hashpower));
+
+
+    return failure_table_full;
+
+}
+
+static cuckoo_status _cuckoo_delete(cuckoo_hashtable_t* h,
+                                    const char* key,
+                                    size_t i1,
+                                    size_t i2,
+                                    size_t keylock) {
+    if (_try_del_from_bucket(h, key, i1, keylock))
+        return ok;
+
+    if (_try_del_from_bucket(h, key, i2, keylock))
+        return ok;
+
+    return failure_key_not_found;
+
+}
+
+static void _cuckoo_clean(cuckoo_hashtable_t* h, size_t size) {
+    size_t i, j, ii;
+
+    for (ii = 0; ii < size && h->expanding; ++ii) {
+        i = h->cleaned_buckets;
+        uint32_t hv;
+        for (j = 0; j < bucketsize; j ++) {
+            if (TABLE_KEY(h, i, j) == 0) {
+                continue;
+            }
+            hv = _hashed_key((char*) &TABLE_KEY(h, i, j));
+            size_t i1 = _index_hash(h, hv);
+            size_t i2 = _alt_index(h, hv, i1);
+            if ((i != i1) && (i != i2)) {
+                //DBG("delete key %u , i=%zu i1=%zu i2=%zu\n", TABLE_KEY(h, i, j), i, i1, i2);
+                TABLE_KEY(h, i, j) = 0;
+                TABLE_VAL(h, i, j) = 0;
+            }
+        }
+        h->cleaned_buckets ++;
+        if (h->cleaned_buckets == hashsize((h->hashpower))) {
+            h->expanding = false;
+            DBG("table clean done, cleaned_buckets = %zu\n", h->cleaned_buckets);
+            return;
+        }
+    }
+    DBG("_cuckoo_clean: cleaned_buckets = %zu\n", h->cleaned_buckets);
+}
+
+
+/********************************************************************
+ *               Interface of cuckoo hash table
+ *********************************************************************/
+
+cuckoo_hashtable_t* cuckoo_init(const int hashtable_init) {
+    cuckoo_hashtable_t* h = (cuckoo_hashtable_t*) malloc(sizeof(cuckoo_hashtable_t));
+    if (!h)
+        goto Cleanup;
+
+    h->hashpower  = (hashtable_init > 0) ? hashtable_init : HASHPOWER_DEFAULT;
+    h->hashitems  = 0;
+    h->kick_count = 0;
+    h->expanding  = false;
+    pthread_mutex_init(&h->lock, NULL);
+
+    h->buckets = malloc(hashsize(h->hashpower) * sizeof(Bucket));
+    if (! h->buckets) {
+        fprintf(stderr, "Failed to init hashtable.\n");
+        goto Cleanup;
+    }
+
+    h->keyver_array = malloc(keyver_count * sizeof(uint32_t));
+    if (! h->keyver_array) {
+        fprintf(stderr, "Failed to init key version array.\n");
+        goto Cleanup;
+    }
+
+    h->cuckoo_path = malloc(MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
+    if (! h->cuckoo_path) {
+        fprintf(stderr, "Failed to init cuckoo path.\n");
+        goto Cleanup;
+    }
+
+    memset(h->buckets, 0, hashsize(h->hashpower) * sizeof(Bucket));
+    memset(h->keyver_array, 0, keyver_count * sizeof(uint32_t));
+    memset(h->cuckoo_path, 0, MAX_CUCKOO_COUNT * sizeof(CuckooRecord));
+
+    return h;
+
+Cleanup:
+    if (h) {
+        free(h->cuckoo_path);
+        free(h->keyver_array);
+        free(h->buckets);
+    }
+    free(h);
+    return NULL;
+
+}
+
+cuckoo_status cuckoo_exit(cuckoo_hashtable_t* h) {
+    pthread_mutex_destroy(&h->lock);
+    free(h->buckets);
+    free(h->keyver_array);
+    free(h);
+    return ok;
+}
+
+cuckoo_status cuckoo_find(cuckoo_hashtable_t* h,
+                          const char *key,
+                          char *val) {
+
+    uint32_t hv    = _hashed_key(key);
+    size_t i1      = _index_hash(h, hv);
+    size_t i2      = _alt_index(h, hv, i1);
+    size_t keylock = _lock_index(hv);
+
+    cuckoo_status st = _cuckoo_find(h, key, val, i1, i2, keylock);
+
+    if (st == failure_key_not_found) {
+        DBG("miss for key %u i1=%zu i2=%zu hv=%zu\n", *((KeyType*) key), i1, i2, hv);
+    }
+
+    return st;
+}
+
+cuckoo_status cuckoo_insert(cuckoo_hashtable_t* h,
+                            const char *key,
+                            const char* val) {
+
+    uint32_t hv = _hashed_key(key);
+    size_t i1   = _index_hash(h, hv);
+    size_t i2   = _alt_index(h, hv, i1);
+    size_t keylock = _lock_index(hv);
+
+    ValType oldval;
+    cuckoo_status st;
+
+    mutex_lock(&h->lock);
+
+    st = _cuckoo_find(h, key, (char*) &oldval, i1, i2, keylock);
+    if  (st == ok) {
+        mutex_unlock(&h->lock);
+        return failure_key_duplicated;
+    }
+
+    st =  _cuckoo_insert(h, key, val, i1, i2, keylock);
+
+    if (h->expanding) {
+        // still some work to do
+        _cuckoo_clean(h, DEFAULT_BULK_CLEAN);
+    }
+
+    mutex_unlock(&h->lock);
+
+    return st;
+}
+
+cuckoo_status cuckoo_delete(cuckoo_hashtable_t* h,
+                            const char *key) {
+
+    uint32_t hv = _hashed_key(key);
+    size_t i1   = _index_hash(h, hv);
+    size_t i2   = _alt_index(h, hv, i1);
+    size_t keylock = _lock_index(hv);
+
+    cuckoo_status st;
+
+    mutex_lock(&h->lock);
+
+    st = _cuckoo_delete(h, key, i1, i2, keylock);
+
+    mutex_unlock(&h->lock);
+
+    return st;
+}
+
+cuckoo_status cuckoo_expand(cuckoo_hashtable_t* h) {
+
+    mutex_lock(&h->lock);
+    if (h->expanding) {
+        mutex_unlock(&h->lock);
+        //DBG("expansion is on-going\n", NULL);
+        return failure_under_expansion;
+    }
+    
+    h->expanding = true;
+
+    Bucket* old_buckets = (Bucket*) h->buckets;
+    Bucket* new_buckets = (Bucket*) malloc(hashsize((h->hashpower + 1)) * sizeof(Bucket));
+    if (!new_buckets) {
+        h->expanding = false;
+        mutex_unlock(&h->lock);
+        return failure_space_not_enough;
+    }
+
+    memcpy(new_buckets, h->buckets, hashsize(h->hashpower) * sizeof(Bucket));
+    memcpy(new_buckets + hashsize(h->hashpower), h->buckets, hashsize(h->hashpower) * sizeof(Bucket));
+
+
+    h->buckets = new_buckets;
+    h->hashpower ++;
+    h->cleaned_buckets = 0;
+
+    // for debug
+    _cuckoo_clean(h, hashsize(h->hashpower));
+    h->expanding = false;
+
+    mutex_unlock(&h->lock);
+
+    free(old_buckets);
+
+    return ok;
+}
+
+void cuckoo_report(cuckoo_hashtable_t* h) {
+
+    size_t sz;
+    sz = sizeof(Bucket) * hashsize(h->hashpower);
+    DBG("total number of items %zu\n", h->hashitems);
+    DBG("total size %zu Bytes, or %.2f MB\n", sz, (float) sz / (1 <<20));
+    DBG("load factor %.4f\n", 1.0 * h->hashitems / bucketsize / hashsize(h->hashpower));
+}
